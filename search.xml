<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Simplex-单纯形算法介绍]]></title>
    <url>%2F2018%2F12%2F18%2FSimplex%2F</url>
    <content type="text"><![CDATA[单纯形算法（Simplex）有什么用？谈到单纯形算法，我们不得不提线性规划，所谓线性规划，就是在满足一定约束下优化目标函数。下面引用几个例子来进行简单介绍。 Food Energy Ca Price 燕麦 110 4 3 牛奶 160 8 9 猪肉 260 14 19 现在我们需要55个单位的Ca和2000个单位的Energy，问我们应该怎么购买最合适。这就是一类最经典的线性优化问题，我们可以很轻松的写出目标函数和约束条件： ​ $min$ $$3X_1+9X_2+19X_3$$ ​ $s.t.$ ​ $110X_1+160X_2+260X_3&gt;=2000$ ​ $4X_1+8X_2+14X_3&gt;=55$ ​ $X_i&gt;=0，i=1,2,3$ 上述不等式表示的含义很简单，$min$表示最小化后面的目标函数，$s.t.$ 表示subject to的缩写，意思是受限于。 针对这类问题，我们曾经学过的方法是图解法，画出可行域（阴影部分）（a），之后使用目标函数(b)在可行域上移动，之后靠直觉确定最优解。 但是计算机可没有人类的直觉！计算机求解这些问题的时候，需要更加通用的方法来求解。于是在二战时期，为了协助政府协调物资人员，前苏联的坎托诺维奇强行提出了Simplex算法。其实该算法的思想也是来自于图解法，我们观察上面的求解过程，可以很明显的发现，最优解一定是在顶点上的！！！！于是这个人就在想，我们是不是随便从一个顶点开始，之后每次迁移到这个顶点的相邻顶点上，对这个凸包每个点遍历一次就能得到答案了？事实确实也确实是这样的，而且可以更简单，实际上我们只需要随便从一个顶点开始，之后暴力这个点相邻的点，然后选择一个下降的方向迁移点就可以，直到当前的点的值最小，那么这个点就是最终的解。 但是为什么可以这样做呢？按照我的理解，因为可行域是一个凸多边形(为什么是凸的？其实画一画，就知道了。不可能是凹的，可行域一定是凸的！！)，那么这个凸多边形的顶点结果是单调的，因为全局最优解只有一个。那么求解过程就好像下山一样，只要每次向下走就可以走到谷底，类似于梯度下降法在凸二次函数上每次沿着下降的方向走，一直迭代就能得到最优解。当然这些是在扯淡，实际上这玩意是被证明了的，而我没看。。。 单纯形算法适用的情况标准的线性规划格式（也叫标准型）： ​ $min$ $c^Tx$ ​ $s.t.$ ​ $A*x&lt;=b$ ​ $x_i&gt;=0，i=1,2,3…,n$ 其中$c$表示的就是每一类$x$的花费，$A$表示的是约束矩阵，$x$表示的是擦书的列向量，$x_i$表示的是每一类的量(针对于整数线性规划，要求$x_i$必须为整数，比如$x_i$表示的是人的数量或者物品的份数) 但是有些时候我们可能碰到一些要最大化的最优化问题，比如我们固定钱数，怎么样买到的能量最多？这时候我们的优化目标变成了$max$，针对这类问题我们转换为标准形式的方式也很简单，$c*-1$ 就变为$min$ 了，同样的道理我们对$A$和$x$都可以这样干。 目标函数是$max$的时候，我们将$c$取反 $Ai*x&gt;=b$,我们将$A_i$和$b$取反 $x&lt;=0$,我们将$x$取反 松弛型和单纯形我们上面介绍了标准型，现在介绍一下松弛型，其实也是一个很简单的东西，由于我们上面都是不等式，实在是太烦了，于是我们想要把不等式优化成等式，于是我们将标准型构造成下面的形式： ​ $min$ $c^Tx$ ​ $s.t.$ ​ $A_i*x+x_{i+n}=b_i$ ​ $x_i&gt;=0，i=1,2,3…,n+m$ 其中$m$表示约束的个数，由于之前的不等式都是$&gt;=$的情况，我们可以减去一个非负的变量使得等号成立。这就是松弛形。 现在介绍单纯形，单纯形其实就是从松弛型过来的，它是为了单纯形算法求解简便一些而存在的，因为它可以导出单纯形表，一般写成如下形式： ​ $min$ $c^Tx$ ​ $s.t.$ ​ $x_{i+n}=b_i-A_ix$ ​ $x_i&gt;=0，i=1,2,3…,n+m$ 其中我们称左边的变量为基本变量，右边的变量称为非基本变量，我们很显然有一组基础解，就是令非基本变量为零，这时候基本变量的值都为其对应的$b_i$。我们一般情况下可以认为基础解就是前面说的可行解区域的一个顶点（因为原本就是边界）。 而单纯形表的初始形式很简单，举个例子 ​ $min$ $-x_1-14x_2-6x_3$ ​ $s.t.$ ​ $x_1+x_2+x_3+x_4$ $=4$ ​ $x_1$ $+x_5$ $=2$ ​ $x_3$ $+x_6$ $=3$ 当前的例子的基本变量为${x_4,x_5,x_6}$,非基本变量为${x_1,x_2,x_3}$。 其单纯形表的形式为: 0 -1 -14 -6 0 0 0 4 1 1 1 1 0 0 2 1 0 0 0 1 0 3 0 0 1 0 0 1 人话解释，第一行表示的是目标函数的系数，但是其中第0个位置表示的是当前目标函数取当前基础解作为解之后求得的值的相反数。后面的每一行表示的都是约束条件$b_i=a_{i1}x_1+a_{i2}x_2+…+a_{i(n+m)}x_{n+m}$ 我们在使用单纯形法进行求解的时候，首先找到第一个目标函数中系数为负的非基本变量$y$，将其增大（这个过程相当于我们在凸包上沿着边缘走到另一个顶点），但是我们怎么确定这个非基本变量$y$最大能增大多少呢？这个其实很简单，只需要令除当前变量的其他变量为0，剩下$b_i$和$y$，我们可以对每个包含$y$的约束条件进行计算约束。找到使其最紧(即在当前的约束条件中让$y$的最大取值最小)的那一个约束即可，再使用当前约束条件下的基本变量与其进行替换即可。由于我们每次可以使约束z向更小的方向迁移，这使得我们的算法不会陷入死循环。 注意，假如对于非基本变量$y$不存在限制最紧的约束条件，那么该组线性规划无解，因为可以无限增大。 再次注意我们的规则(Bland规则)： 找到第一个目标函数中系数为负的非基本变量 找到限制最紧的约束条件 使用当前约束条件下的基本变量(也叫替入变量)与非基本变量（也叫替出变量）进行替换 我们对上述单纯形表进行一次示范操作： 首先我们看到第一个非基本变量$x_1$的系数为负数。那么我们开始对$x_1$进行增大。 对于第一个约束条件有$x_1=4$ 对于第二个约束条件有$x_1=2$ 对于第三个约束条件有$x_1=3$ 由于第二个约束是最紧的，那么我们选择第二个约束中的$x_5$作为替出变量，此时有单纯形表的变化为 2 0 -14 -6 0 1 0 2 0 1 1 1 -1 0 2 1 0 0 0 1 0 3 0 0 1 0 0 1 由于我们在替出时将$x_1=2-x_5$带入，很明显可以将单纯形表进行转换。如果没有想清楚的话我们可以手动带入一下即可。 一直重复这个操作，直到所有的非基本变量的系数都大于零（顶点无法再迁移），那么程序就求出了最优解。 注意，本文其实未完待续，因为其实在实现算法中间存在很多细节，但本文的目的是让读者对该算法有个系统的了解，明白算法的原由，至于一些具体的细节，读者可以参考链接进行进一步的了解！ 给出一份Simplex的模板与其应用，所求解的题目链接：BZOJ 1061： 注意！！该模板求解的是： ​ $max$ $c^Tx$ ​ $s.t.$ ​ $A*x&lt;=b$ ​ $x_i&gt;=0，i=1,2,3…,n$这类问题，稍稍转换一下就好了。之所以选择这个作为模板，是因为这份模板直接省去了替出变量，节省了大量空间，而且极其富有技巧性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;typedef double DB;typedef long long LL;const int maxn = 1005, maxm = 10005;const DB inf = 0x3f3f3f3f3f3f3f3f, eps = 1e-7;int n, m;DB b[maxm], c[maxn], cof[maxm][maxn], ans;//约束、目标函数的系数、约束矩阵inline void pivot(int id, int pos) &#123; b[id] /= cof[id][pos];//首先归一化 cof[id][pos] = 1 / cof[id][pos];//将变量直接改变为松弛变量，技巧的地方 for(int i = 1; i &lt;= n; i++) if(i != pos) cof[id][i] *= cof[id][pos];//归一化 for(int i = 1; i &lt;= m; i++) if(i != id &amp;&amp; fabs(cof[i][pos]) &gt; eps) &#123;//当前约束条件包含约束最紧的变量 b[i] -= cof[i][pos] * b[id];//搞死小圆(高斯消元)的方法更新变量的系数和b的值 for(int j = 1; j &lt;= n; j++) if(j != pos) cof[i][j] -= cof[i][pos] * cof[id][j]; cof[i][pos] = -cof[i][pos] * cof[id][pos];//将变量直接改变为松弛变量，技巧的地方 &#125; ans += c[pos] * b[id];//对c进行消元 for(int i = 1; i &lt;= n; i++) if(i != pos) c[i] -= c[pos] * cof[id][i]; c[pos] = -c[pos] * cof[id][pos];//将变量直接改变为松弛变量，技巧的地方&#125;inline DB simplex() &#123; while(1) &#123; int pos, id; for(pos = 1; pos &lt;= n; pos++) if(c[pos] &gt; eps) break;//找到第一个系数大于0的变量，进行增大 if(pos == n + 1) return ans;//找不到了结束，返回答案 DB tmp = inf; for(int i = 1; i &lt;= m; i++) if(cof[i][pos] &gt; eps &amp;&amp; b[i] / cof[i][pos] &lt; tmp) tmp = b[i] / cof[i][pos], id = i;//找到约束最紧的那个约束条件 if(tmp == inf) return inf; pivot(id, pos);//进行顶点的迁移（旋转） &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%lf", &amp;c[i]);//其实将min改为max问题，可以直接采用结论，求对偶问题即可。 for(int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); for(int j = x; j &lt;= y; j++) cof[i][j] = 1; scanf("%lf", &amp;b[i]); &#125; printf("%lld\n", LL(simplex() + 0.5)); return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Simplex</tag>
        <tag>最优化</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
</search>
