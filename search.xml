<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[kickstart-2019 Round C]]></title>
    <url>%2Fkickstart2019C%2F</url>
    <content type="text"><![CDATA[Round C这次笔试题的链接。这次的笔试题难度适中，主要是记录一下最后一道题的解法。 A题给我们一个二维平面，起始我们在某一个位置，之后我们可以四联通的上下左右进行滑动。所谓滑动，比较有意思，意思是，我们每次移动的时候如果到了一个我们之前经过的点，那么我们可以继续沿该方向滑动，直到滑到一个曾经没到过的点，此时再进行下一个方向的滑动。图大小$C,R&lt;5e4$，滑动次数$n&lt;5e4$。 想法初看这个题目，感觉是一个链表题，每次移动的时候，更新上下左右的节点，但是仔细想想操作的时候比较复杂。不过我们可以再换一个角度想这个题目，我们动态的申请空间，维护最外层节点，层层向外扩展，之后对于每一行维护左右滑动时有可能去的节点集合，对于每一列上下滑动时可能去的节点集合。由于每次到一个新节点，最多扩展三个可用节点，所以这种想法是很高效的。实际操作的时候，我用了set去存每一行或者每一列的可能节点集合，使用map标记哪些节点已经访问过，之后在滑动的过程中，我们只需要在set中二分即可。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; R[50005],C[50005];set&lt;int&gt; ::iterator ite;map&lt;pair&lt;int,int&gt;,int &gt;ma;int main(void) &#123; int ca=1,i,j,n,m,T,x,y,c,r; string s; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d %d %d %d",&amp;n,&amp;r,&amp;c,&amp;x,&amp;y); for(i=1;i&lt;=r;i++)&#123; R[i].clear(); &#125; for(i=1;i&lt;=c;i++)&#123; C[i].clear(); &#125; ma.clear(); ma[make_pair(x,y)]=1; R[x].insert(y+1); R[x].insert(y-1); C[y].insert(x+1); C[y].insert(x-1); cin&gt;&gt;s; for(i=0;s[i];i++)&#123; if(s[i]=='E')&#123; while(true)&#123; ite=R[x].upper_bound(y); R[x].erase(ite); if(ma[make_pair(x,*ite)]==1)&#123; continue ; &#125; else &#123; y=*ite; break; &#125; &#125; &#125; if(s[i]=='W')&#123; while(true)&#123; ite=R[x].lower_bound(y); ite--; R[x].erase(ite); if(ma[make_pair(x,*ite)]==1)&#123; continue ; &#125; else &#123; y=*ite; break; &#125; &#125; &#125; if(s[i]=='N')&#123; while(true)&#123; ite=C[y].lower_bound(x); ite--; C[y].erase(ite); if(ma[make_pair(*ite,y)]==1)&#123; continue ; &#125; else &#123; x=*ite; break; &#125; &#125; &#125; if(s[i]=='S')&#123; while(true)&#123; ite=C[y].upper_bound(x); C[y].erase(ite); if(ma[make_pair(*ite,y)]==1)&#123; continue ; &#125; else &#123; x=*ite; break; &#125; &#125; &#125; ma[make_pair(x,y)]=1; if(ma[make_pair(x,y+1)]==0) R[x].insert(y+1); if(ma[make_pair(x,y-1)]==0) R[x].insert(y-1); if(ma[make_pair(x+1,y)]==0) C[y].insert(x+1); if(ma[make_pair(x-1,y)]==0) C[y].insert(x-1); &#125; printf("Case #%d: ",ca++); printf("%d %d\n",x,y); &#125;&#125; B题给我们一个二维平面，希望我们找到一个尽量大的合法子矩阵。所谓合法，即是子矩阵的每一行中最大元素和最小元素的差小于$k$即可。之后输出最大的面积即可。矩阵大小$R,C&lt;300$ 想法这个题目的解法就比较直观了，首先对每一行的每一个元素计算最远可以扩展到哪一个位置这个过程可以使用队列+multiset维护一下，之后我们对每一列查询给定直方图，求最大子矩阵问题即可，具体问题可以参考这一题 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;int A[305][305],flag[305][305];queue&lt;int&gt; que;multiset&lt;int&gt; s;struct node &#123; int h , pos;&#125; a[305];int maxx=0,pos;stack&lt;node&gt; q;int main() &#123; int i,j,n,m,T,r,c,k,MIN,MAX,t,ans,ca=1; scanf("%d",&amp;T); while(T--) &#123; scanf("%d %d %d",&amp;r,&amp;c,&amp;k); for(i=0; i&lt;r; i++) &#123; for(j=0; j&lt;c; j++) &#123; scanf("%d",&amp;A[i][j]); &#125; &#125; while(que.size()) que.pop(); for(i=0; i&lt;r; i++) &#123; s.clear(); for(j=0; j&lt;c; j++) &#123; s.insert(A[i][j]); que.push(j); while(s.size()) &#123; MIN=*s.begin(); MAX=*s.rbegin(); if(MAX-MIN&lt;=k) break; t=que.front(); que.pop(); flag[i][t]=j-1; s.erase(s.find(A[i][t])); &#125; &#125; while(que.size()) &#123; t=que.front(); que.pop(); flag[i][t]=j-1; &#125; &#125;/* for(i=0; i&lt;r; i++) &#123; for(j=0; j&lt;c; j++) &#123; printf("%d ",flag[i][j]); &#125; printf("\n"); &#125;*/ ans=0; for(j=0; j&lt;c; j++) &#123; for(i=0;i&lt;r;i++)&#123; a[i].h=flag[i][j]-j+1,a[i].pos=i; &#125; a[r].h=0; a[r].pos=r; while(q.size()) q.pop(); maxx=0; for(i=0; i&lt;=r; i++) &#123; if(q.empty() || q.top().h&lt;a[i].h) q.push(a[i]); else if(q.top().h!=a[i].h) &#123; int pos1; while(!q.empty()&amp;&amp;q.top().h&gt;a[i].h) &#123; node x=q.top(); int sum=0; q.pop(); sum=x.h*(i-x.pos); maxx=max(maxx,sum); pos1=x.pos; &#125; node G; G.h=a[i].h; G.pos=pos1; q.push(G); &#125; &#125; ans=max(ans,maxx); &#125; printf("Case #%d: %d\n",ca++,ans); &#125;&#125; C题这个问题是给一个分组背包问题，之后求在装满背包的情况下，最小的花费是多少。具体还有一些细节，请仔细看题。 想法这个题目就是十分直接的dp啦，不过中间有些小细节，我们首先应该加一维表示当前作为最后的结束位置。之后我们还需要改一下我们一贯的dp方式，因为之前都是给定背包大小，求最大价值，但是这次是给定背包大小，求最小价值。这个时候我们需要初始化的时候为INF就好了，之后背包大小为0的时候为0就好了。这样可以保证转移的时候背包大小一定是满的。这个题目还是很有意思。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; vec[1005];int dp[1005][2],pos[1005];int main(void) &#123; int T,i,j,k,n,m,col,K,ca=1; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;m); for(i=0;i&lt;1005;i++) vec[i].clear(); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;pos[i]); &#125; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;col); vec[col].push_back(pos[i]); &#125; for(i=0;i&lt;1005;i++) sort(vec[i].begin(),vec[i].end()); for(i=0;i&lt;1005;i++)&#123; dp[i][0]=dp[i][1]=1e9; &#125; dp[0][0]=dp[0][1]=0; for(i=0;i&lt;1005;i++)&#123; for(j=m;j;j--)&#123;//共用数组01背包，逆向 for(k=0;k&lt;vec[i].size();k++)&#123; K=k+1; if(K&gt;j) break; dp[j][0]=min(dp[j][0],dp[j-K][0]+2*vec[i][k]); dp[j][1]=min(dp[j][1],dp[j-K][1]+2*vec[i][k]); dp[j][1]=min(dp[j][1],dp[j-K][0]+vec[i][k]); &#125; &#125; &#125; printf("Case #%d: %d\n",ca++,dp[m][1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>GCJ</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BPalgorithm-反向传播算法]]></title>
    <url>%2FBP%2F</url>
    <content type="text"><![CDATA[BP算法这个算法是用来更新神经网络中的参数的，对于理解神经网络的运作可以说是至关重要。在我刚接触神经网络的时候，第一时间感觉神经网络是玄学，你就搭一个网络之后给一些训练数据，就能有好的效果了？？？这种过于智能的方法与我原本对算法的理解产生了极大的偏差。但是， 抱歉，BP算法是真的可以为所欲为。确实只需要搭一个网络结构，再给一些数据，它能更新参数，而且理论上两层的神经网络加上非线性激活函数就能够拟合任何非线性函数。反向传播属于监督学习算法，通过调节各层的权重，使网络学会由“输入-输出对”组成的训练组。其调节过程按照从后向前的形式： 首先修正：“输出层至最后一个隐含层”的连接权重 再修正：“最后一个隐含层至倒数第二个隐含层”的连接权重 … 最后修正：“第一隐含层至输入层”的连接权重。 本文将会结合自动化所模式识别课件中的一些图来介绍一下三层全连接网络的BP算法流程，力求给出一个简单的讲解。同时为了让本文有一些实际价值，最后将会给出一个简单的BP代码。 需要知道的知识链式法则链式法则用于复合函数求导，具体例子如下： 设 f(x)=g_1(g_2(g_3(...(g_n(x)))))令 h_2(x)=g_2(g_3(...(g_n(x)))),\\ h_3(x)=g_3(g_4(...(g_n(x)))),\\ ....我们有： \begin{eqnarray*} \frac {\partial f(x)} {\partial x} & =& \frac {\partial g_1(h_2(x))} {\partial h_2} \frac {\partial h_2(x)} {\partial x}\\ & = &\frac {\partial g_1(h_2(x))} {\partial h_2} \frac {\partial h_2(h_3(x))} {\partial h_3}\frac {\partial h_3(x)} {\partial x} \\ &= &... \\ &= &\frac {\partial g_1(h_2(x))} {\partial h_2} \frac {\partial h_2(h_3(x))} {\partial h_3}...\frac {\partial g_n(x)} {\partial x} \end{eqnarray*}tanh tanh是一个常见的S型函数，也是双曲函数中的一个，tanh()为双曲正切。在数学中，双曲正切“tanh”是由双曲正弦和双曲余弦这两种基本双曲函数推导而来。 公式如下： \tanh x= \frac {\sinh x} {\cosh x}= \frac {e^x-e^{-x}} {e^x+e^{-x}}请注意其导数形式： \tanh' x=1- \tanh ^2 x可以看到其导数的值可以用函数本身来表示，这是tanh在之前的神经网络中常用的原因之一，求导很简单。 sigmoid Sigmoid函数是一个在生物学中常见的S型函数，也称为S型生长曲线。 在信息科学中，由于其单增以及反函数单增等性质，Sigmoid函数常被用作神经网络的阈值函数，将变量映射到0,1之间。 公式如下： S(x)=\frac 1 {1+e^{-x}}请注意其导数形式： S'(x)=\frac {e^{-x}} {(1+e^{-x})^2}=S(x)(1-S(x))可以看到其导数的值可以用函数本身来表示，这是sigmoid在之前的神经网络中常用的原因之一，求导很简单。 所以我们后面的推导默认使用这两个激活函数啦！ 网络结构下图是本文所使用的网络结构： 其中我们规定以下参数： 训练数据输入输出对： $\{x_i^k,t_i^k\}$ 输出层结点的输出: $z_j^k$ 隐含层结点的输出：$y_h^k$ 输入层结点$i$至隐含层结点$h$的权重：$w_{ih}$ 隐含层结点$h$至输出层结点$j$的权重：$w_{hj}$ 上标 $k$ 表示训练对的序号，即第$k$个样本 我们使用以下损失函数： loss=\frac 1 2 \sum_{j=1}^c(t_j-z_j)^2首先进行前向传播计算中间值 对第$k$个样本，隐含层$h$结点的输入加权和为： $net_h^k=\sum_i w_{ih}x_i^k$ 隐含层中节点$h$激励后的值：$y_h^k=f(net_h^k)=f(\sum_i w_{ih}x_i^k)$ 输出层中节点$j$的输入加权和为：$net_j^k=\sum_hw_{hj}y_h^k=\sum_hw_{hj}f(\sum_i w_{ih}x_i^k)$ 激励后，输出层$z$的输出：$z_j^k=f(net_j^k)=f(\sum_hw_{hj}y_h^k)=f(\sum_hw_{hj}f(\sum_i w_{ih}x_i^k))$ 上面的公式虽然看起来很多，但是实际上只是展开了而已，建议手写一下。 通过上述推导，我们已经将第$k$个样本进行了前向传播，我们所得到的输出$z$如下： z_j^k=f(net_j^k)=f(\sum_hw_{hj}y_h^k)=f(\sum_hw_{hj}f(\sum_i w_{ih}x_i^k))我们使用最小均方误差损失函数，有： J(w)^k=\frac 1 2\sum_j(t_j^k-z_j^k)^2将损失函数展开： \begin{eqnarray*} J(w)^k & = &\frac 1 2\sum_j(t_j^k-z_j^k)^2\\ &=&\frac 1 2\sum_j(t_j^k-f(net_j^k))^2\\ &=&\frac 1 2\sum_j(t_j^k-f(\sum_hw_{hj}y_h^k))^2\\ &=&\frac 1 2\sum_j(t_j^k-f(\sum_hw_{hj}f(net_h^k)))^2\\ &=&\frac 1 2\sum_j(t_j^k-f(\sum_hw_{hj}f(\sum_iw_{ih}x_i^k)))^2\\ \end{eqnarray*}首先我们计算输出层到隐含层的增量 \begin{eqnarray*} \Delta w_{hj}&=&- \eta \frac {\partial J(w)} {\partial w_{hj}} \\ &=&- \eta \sum_k \frac {\partial J(w)^k} {\partial z_j^k} \frac {\partial z_j^k} {\partial w_{hj}}\\ &=&\eta \sum_k (t_j^k-z_j^k) \frac {\partial z_j^k} {\partial w_{hj}}\\ &=&\eta \sum_k (t_j^k-z_j^k) \frac {\partial z_j^k} {\partial net_{j}^k} \frac {\partial net_{j}^k} {\partial w_{hj}} \\ &=&\eta \sum_k (t_j^k-z_j^k)f'(net_j^k)\frac {\partial net_{j}^k} {\partial w_{hj}}\\ &=&\eta \sum_k (t_j^k-z_j^k)f'(net_j^k)y_h^k\\ &=&\eta \sum_k (t_j^k-z_j^k)f'(net_j^k)y_h^k\\ &=&\eta \sum_k \delta_j^k y_h^k\\ \end{eqnarray*}我们一步一步进行计算，可以得到上面的递推式，由于我们进过了一次前向传播，最后等式里面的所有值都是定值，于是我们可以算出准确的梯度值$\Delta w_{hj}$。 为了使上式看起来简单，我们通常定义一个$\delta $规则，这里的定义如下： \delta_j^k=\frac {\partial J(w)} {net_j^k}=(t_j^k-z_j^k)f'(net_j^k)=\Delta _j^kf'(net_j^k)在这里特别需要注意的是$\Delta _j^k$ 原本的形式应该是$-(t_j^k-z_j^k)$。但是负号和最初的$-\eta $抵消了。 如图所示，我们可以理解$\delta_j^k$为，对于第$k$个样本来说：当前层第$j$个节点所收集到的误差信号（这里就是$(t_j^k-z_j^k)$）乘以当前第$j$个节点的加权和对激励函数的导数（这里就是$f’(net_j^k)$)，计算完了之后就将$\delta_j^k$作为传递给下一层的误差信号。 之后隐藏层的第$h$个节点到输出层第$j$个节点的增量形式可以记作: \Delta w_{hj}=\eta \sum_k \delta_j^k y_h^k图解如下： 注意：这个时候我们就可以得到BP算法增量的的通解形式了: \Delta w_{hj}^k=\eta \delta_j^k y_h^k 之后我们计算输出层到输入层的增量请注意，这里由于$j$是不固定的，所以我们需要有$\sum_j$。 \begin{eqnarray*} \Delta w_{ih}&=&- \eta \frac {\partial J(w)} {\partial w_{ih}} \\ &=&- \eta \sum_k \sum_j \frac {\partial J(w)^k} {\partial z_j^k} \frac {\partial z_j^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k) \frac {\partial z_j^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k) \frac {\partial z_j^k} {\partial net_{j}^k} \frac {\partial net_{j}^k} {\partial w_{ih}} \\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k)f'(net_j^k)\frac {\partial net_{j}^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k)f'(net_j^k)\frac {\partial net_{j}^k} {\partial y_h^k} \frac {\partial y_h^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k)f'(net_j^k)w_{hj} \frac {\partial y_h^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k)f'(net_j^k)w_{hj} \frac {\partial y_h^k} {\partial net_{h}^k} \frac {\partial net_{h}^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k)f'(net_j^k)w_{hj} f'(net_h^k) \frac {\partial net_{h}^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k)f'(net_j^k)w_{hj} f'(net_h^k) x_i\\ &=&\eta \sum_k \sum_j \frac {\partial J(w)^k} {\partial net_h^k} \frac {\partial net_h^k} {w_{ih}} \end{eqnarray*}这个递推过程太复杂了，我们通常使用$\delta$规则简化递推式，请注意以下的递推过程： \begin{eqnarray*} \Delta w_{ih}&=&- \eta \frac {\partial J(w)} {\partial w_{ih}} \\ &=&- \eta \sum_k \sum_j \frac {\partial J(w)^k} {\partial z_j^k} \frac {\partial z_j^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k) \frac {\partial z_j^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j (t_j^k-z_j^k) \frac {\partial z_j^k} {\partial net_{j}^k} \frac {\partial net_{j}^k} {\partial w_{ih}} \\ &=&\eta \sum_k \sum_j \delta_j^k \frac {\partial net_{j}^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j \delta_j^k\frac {\partial net_{j}^k} {\partial y_h^k} \frac {\partial y_h^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j \delta_j^k w_{hj}\frac {\partial y_h^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j \delta_j^k w_{hj} \frac {\partial y_h^k} {\partial net_{h}^k} \frac {\partial net_{h}^k} {\partial w_{ih}}\\ &=&\eta \sum_k \sum_j \delta_j^k w_{hj} f'(net_h^k) \frac {\partial net_{h}^k} {\partial w_{ih}}\\ &=&\eta \sum_k \delta_h^k x_i\\ \end{eqnarray*} 于是我们可以得出下面的结论： 请注意这里的$\delta $ 和之前有一些不一样，这里的$\delta $包含了边权$w_{hj}$。 来一个更加形象的例子来解释$\delta $： 以下是本文最重要的两句话: 我们在当前节点求收集到的损失$\delta $的时候，计算的是上一层收集到的损失$\delta $与边权乘积的加权和之后，再乘以当前节点的加权和对激励函数的导数。 我们在更新某一条边权的时候，我们只需要考虑输出节点的收集到的损失$\delta$乘以当前节点的加权和的激励后的值即可。 于是我们可以得到更加普通的求增量$\Delta$的形式： \Delta w_{in\rightarrow o}=\eta \sum_k \delta_o^k y_{in}其中$in$表示输入节点， $o$表示输出节点，$y_{in}$表示当前节点的加权和的激励值，$k$表示的是样本编号，$\eta$表示学习率。 于是我们可以得到更加普通的收集损失$\delta $的形式： \delta_{in}^k=f'(net_{in}^k) \sum_o w_{in\rightarrow o}\delta_o^k其中$in$表示输入节点， $o$表示输出节点，$net_{in}$表示当前节点的加权和，$k$表示的是样本编号，$\eta$表示学习率。 到此，BP算法在DNN上的推导我们已经结束了，如果读者理解了上面的两个式子，就说明对BP算法有了一定的了解啦！ 代码一份BP代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import numpy as npimport mathw0=[[ 1.58, 2.32, -5.8], [ 0.67, 1.58, -4.78], [ 1.04, 1.01, -3.63],[-1.49, 2.18, -3.39], [-0.41, 1.21, -4.73], [1.39, 3.16, 2.87],[ 1.20, 1.40, -1.89], [-0.92, 1.44, -3.22], [ 0.45, 1.33, -4.38],[-0.76, 0.84, -1.96]]w1=[[ 0.21, 0.03, -2.21], [ 0.37, 0.28, -1.8], [ 0.18, 1.22, 0.16],[-0.24, 0.93, -1.01], [-1.18, 0.39, -0.39], [0.74, 0.96, -1.16],[-0.38, 1.94, -0.48], [0.02, 0.72, -0.17], [ 0.44, 1.31, -0.14],[ 0.46, 1.49, 0.68]]w2=[[-1.54, 1.17, 0.64], [5.41, 3.45, -1.33], [ 1.55, 0.99, 2.69],[1.86, 3.19, 1.51], [1.68, 1.79, -0.87], [3.51, -0.22, -1.39],[1.40, -0.44, -0.92], [0.44, 0.83, 1.97], [ 0.25, 0.68, -0.99],[ 0.66, -0.45, 0.08]]learning_rate=0.1single=0layer_size=[3,10,3]layer_function=["tanh","sigmoid"]layer_arcfunction=["arctanh","arcsigmoid"]layer=[]def tanh(x): return math.tanh(x) #return (math.exp(x)-math.exp(-x))/(math.exp(x)+math.exp(-x))def arctanh(x): return 1.0-tanh(x)*tanh(x)def sigmoid(x): return 1.0/(1+math.exp(-x))def arcsigmoid(x): return sigmoid(x)*(1-sigmoid(x))def predict(train,test): net=[] fnet=[] res=np.copy(train) net.append(np.copy(train)) fnet.append(np.copy(train)) for i in range(len(layer)): res=np.dot(res,layer[i])#计算下一层的结果 net.append(np.copy(res))#将结果存起来 for vector in res: for j in range(len(vector)): vector[j]=globals().get(layer_function[i])(vector[j])#将每一层得到的结果激励 fnet.append(np.copy(res))#将激励后的结果存起来 fres=np.copy(fnet[-1]) fres=np.subtract(test,fres) fres=np.square(fres) ans=fres.sum()#计算答案 res = np.copy(net[-1])#最后一层的未激励后的结果 fres= np.copy(fnet[-1])#最后一层激励后的结果 subfres=np.subtract(test,fres)#（t-z）的结果 delta=[] update_layer = [] for i in range(len(layer)): delta.append(np.zeros((layer_size[i+1],len(train))))#创建delta矩阵记录结果，这个非常关键的 update_layer.append(np.ones_like(layer[i]) - 1)#创建一个相同维度的更新权重的矩阵 deep=len(layer)-1 for j in range(layer_size[-1]):#第几个节点 for k in range(len(train)):#第几个样本 delta[deep][j][k]=globals().get(layer_arcfunction[deep])(res[k][j])*(subfres[k][j])#计算最后一层的误差，表示的是最后一层第j个节点第k个样本的误差 H=layer_size[-2]#得到倒数第二层的节点数 J=layer_size[-1]#得到倒数第一层的节点数 fres=fnet[-2]#得到倒数第二层激励后的结果y^k_h for h in range(H): for j in range(J): loss=0 for k in range(len(train)): loss+=delta[deep][j][k]*fres[k][h] update_layer[deep][h][j]=learning_rate*loss deep-=1#找下一层的 res = np.copy(net[-2])#得到倒数第二层的未激励后的结果net^k_h for h in range(layer_size[-2]):#第几个节点 for k in range(len(train)):#第几个样本 loss=0 for j in range(layer_size[-1]):#计算误差。 loss+=delta[deep+1][j][k]*layer[-1][h][j] delta[deep][h][k]=globals().get(layer_arcfunction[deep])(res[k][h])*loss#当前节点的倒数加权和的倒数乘以收集到的误差 I = layer_size[-3]#得到倒数第三层的节点 H = layer_size[-2]#得到倒数第二层的节点 fres = train#第一层的就得用train了 for i in range(I): for h in range(H): loss = 0 for k in range(len(train)): loss += delta[deep][h][k] * fres[k][i] update_layer[deep][i][h] = learning_rate * loss for i in range(len(layer)): layer[i]=np.add(layer[i],update_layer[i])#更新权重 return ansdef learn(train,test,single): cnt=0 if single:#单个来更新 for i in range(len(train)): cnt+=predict(np.array([train[i]]),np.array([test[i]])) else :#批处理来更新 cnt += predict(train, test) return cntif __name__ == '__main__': train = w0 + w1 + w2#训练数据 test = [] for i in range(10): test.append([1,0,0]) for i in range(10): test.append([0,1,0]) for i in range(10): test.append([0,0,1])#训练数据的标签 train = np.array(train) test = np.array(test) np.random.seed(19980731)#杨超越 for i in range(len(layer_size)): j=i+1 if(j==len(layer_size)): break matrix=np.random.randn(layer_size[i],layer_size[j])#初始化权重向量 layer.append(matrix) for i in range(1000):#训练轮数 print("After ",i," single" if single else " batch","learning the loss:",learn(train,test,single))#0.713826927619 训练1000轮的总loss]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>BP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kickstart-2019 Round A]]></title>
    <url>%2Fkickstart2019A%2F</url>
    <content type="text"><![CDATA[Round A这次笔试题的链接。主要对第二题做一下笔记，加深一下对于曼哈顿距离的理解。 A题这个题目意思很简单，给我们$n$个数，让我们选$P$个出来，问我们选$P$个数出来之后，要求所有的数都和当前的最大数一样所需要花费的时间，每一个单位时间可以让某个数的数值+1 想法明显是一个贪心的题目，排序之后，用前缀和维护一下就行了。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;long long a[100005],pre[100005];int main(void)&#123; int T; int i,j,n,m,ca=1,P; long long ans; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;P); for(i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; sort(a+1,a+n+1); pre[0]=0; for(i=1;i&lt;=n;i++)&#123; pre[i]=a[i]+pre[i-1]; &#125; ans=-1; for(i=P;i&lt;=n;i++)&#123; if(ans==-1)&#123; ans=P*a[i]-(pre[i]-pre[i-P]); &#125; ans=min(ans,P*a[i]-(pre[i]-pre[i-P])); &#125; printf("Case #%d: %lld\n",ca++,ans); &#125;&#125; B题这个题目蛮有意思的，比赛的时候没有想到怎么维护，还是太菜了，在这里好好总结一下。题意很简单，给我们一个二维矩阵，‘1’表示有一个投递点，‘0’表示需要收快递的点。每个收快递的点到他拿到快递的时间等于离他最近的投递点的曼哈顿距离，现在的问题是，在我们可以再添加一个投递点的情况下，每个收快递点的最大时间最小的值为多大？同时矩阵的大小小于250*250。 想法首先，看到题目的问法，我们可以瞬间反应过来这是一个二分的题目，我们需要回答的子问题是我们在可以添加一个投递点的情况下，时间的最大值能小于$k$吗？这个问题比赛的时候没有想到应该怎么做。只想到了一点点思路，但是还是差的太远了。 首先，我们应该想到这么一个方向，对于点$(x,y)$而言，$k$步所能达到的点$(X,Y)$，应该满足$X+Y&lt;=x+y+k$。 举个例子： (x,y)=(2,2)，k=4，(X,Y)=（4,4）是合法的。 但是我们也可以发现反例。 (x,y)=(4,5)，k=0，(X,Y)=（5,4）是不合法的，但是仍然满足上面的式子。 说明上面的式子并不严格。比赛时，我也只走到了这一步。。。 事实上，还有另一个式子也是同时成立的。对于点$(x,y)$而言，$k$步所能达到的点$(X,Y)$，应该满足$X-Y&gt;=x-y-k$。 换句话说，两个点的曼哈顿距离等于: ManhaDis(x1,y1,x2,y1)=\max(abs(x1+y1-(x2+y2)),abs(x1-y1-(x2-y2)))于是我们只需要找到最大的$x+y$，$x-y$。最小的$x-y$，$x+y$ 值。之后枚举新的投递点的下标$i,j$，如果这四种极端情况下$i,j$都能通过小于等于$k$步到达的话，说明就存在这样的投递点。那么外面再套一层二分的话，时间复杂度是$O(nm\log(n+m))$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;string s[255];int i,j,n,m,dis[255][255],dx[]=&#123;-1,1,0,0&#125;,dy[]=&#123;0,0,1,-1&#125;;struct node&#123; int x,y,now;&#125;;queue&lt;node&gt; que;void bfs()&#123; int i,j; node t,tt; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(s[i][j]=='1') &#123; t.x=i; t.y=j; t.now=0; que.push(t); dis[i][j]=0; &#125; &#125; &#125; while(que.size())&#123; t=que.front(); que.pop(); for(i=0;i&lt;4;i++)&#123; tt.x=t.x+dx[i]; tt.y=t.y+dy[i]; tt.now=t.now+1; if((tt.x&gt;=0)&amp;&amp;(tt.x&lt;n)&amp;&amp;(tt.y&gt;=0)&amp;&amp;(tt.y&lt;m)&amp;&amp;(s[tt.x][tt.y]=='0'))&#123; s[tt.x][tt.y]='1'; dis[tt.x][tt.y]=tt.now; que.push(tt); &#125; &#125; &#125;&#125;int check(int x)&#123; int i,j,upleft,upright,downleft,downright; upright=downright=-1e9; upleft=downleft=1e9; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(dis[i][j]&gt;x)&#123; upright=max(upright,i+j); downright=max(downright,i-j); upleft=min(upleft,i+j); downleft=min(downleft,i-j); &#125; &#125; &#125; if(upright==-1e9) return 1; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;m;j++)&#123; if(abs((i+j)-upright)&lt;=x&amp;&amp;abs((i+j)-upleft)&lt;=x &amp;&amp;abs((i-j)-downright)&lt;=x&amp;&amp;abs((i-j)-downleft)&lt;=x) return 1; &#125; &#125; return 0;&#125;int main() &#123; int ca=1,T,i,j,l,r,M; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;m); for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;s[i]; &#125; memset(dis,0,sizeof(dis)); bfs(); printf("Case #%d: ",ca++); l=0;r=n+m; while(l&lt;r)&#123; M=(l+r)/2; if(check(M)) r=M; else l=M+1; &#125; printf("%d\n",l); &#125;&#125; C题不是很会。。。有时间再仔细想想。]]></content>
      <categories>
        <category>GCJ</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题解]]></title>
    <url>%2Fcoding-interviews%2F</url>
    <content type="text"><![CDATA[剑指offer部分题解1在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 12345678910111213class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int i,MAX=INT_MAX; for(i=0;i&lt;array.size();i++)&#123; array[i].push_back(MAX); if(target==*lower_bound(array[i].begin(),array[i].end(),target))&#123; return 1; &#125; &#125; return 0; &#125;&#125;; 2请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 123456789101112131415class Solution &#123;public: void replaceSpace(char *str,int length) &#123; string s; for(int i=0;str[i];i++)&#123; if(str[i]==' ')&#123; s+="%20"; &#125; else &#123; s+=str[i]; &#125; &#125; strcpy(str,s.c_str()); &#125;&#125;; 3输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 1234567891011121314151617181920212223242526/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; stack&lt;int&gt; sta; vector&lt;int&gt; ret; while(head!=NULL)&#123; sta.push(head-&gt;val); head=head-&gt;next; &#125; while(sta.size())&#123; int t=sta.top(); sta.pop(); ret.push_back(t); &#125; return ret; &#125;&#125;; 4输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 123456789101112131415161718192021222324252627282930/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; vector&lt;int&gt; Lpre,Lvin,Rpre,Rvin; int i,j=1; for(i=0;;i++,j++)&#123; if(vin[i]==pre[0]) break; Lvin.push_back(vin[i]); Lpre.push_back(pre[j]); &#125; for(i++;i&lt;vin.size();i++,j++)&#123; Rvin.push_back(vin[i]); Rpre.push_back(pre[j]); &#125; TreeNode *head; head=new TreeNode(pre[0]); if(Lpre.size()!=0) head-&gt;left=reConstructBinaryTree(Lpre,Lvin); if(Rpre.size()!=0) head-&gt;right=reConstructBinaryTree(Rpre,Rvin); return head; &#125;&#125;; 5用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 12345678910111213141516171819202122232425class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; int t; if(!stack2.size())&#123; while(stack1.size())&#123; t=stack1.top(); stack2.push(t); stack1.pop(); &#125; &#125; t=stack2.top(); stack2.pop(); return t; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 6把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 12345678910111213class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int L,R,M; L=0;R=rotateArray.size(); while(L&lt;R)&#123; M=(L+R)/2; if(rotateArray[M]&gt;rotateArray[0]) L=M+1; else R=M; &#125; return rotateArray[L]; &#125;&#125;; 7大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 1234567891011class Solution &#123;public: int dp[40]=&#123;0&#125;; int Fibonacci(int n) &#123; if(n==0) return 0; if(n==1) return 1; if(n==2) return 1; if(dp[n]!=0) return dp[n]; return dp[n]=Fibonacci(n-1)+Fibonacci(n-2); &#125;&#125;; 8一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 12345678910class Solution &#123;public: int dp[400]=&#123;0&#125;; int jumpFloor(int number) &#123; if(number==0) return 1; if(number==1) return 1; if(dp[number]!=0) return dp[number]; return dp[number]=jumpFloor(number-1)+jumpFloor(number-2); &#125;&#125;; 9一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 123456789101112class Solution &#123;public: int dp[400]; int jumpFloorII(int number) &#123; int i,sum=1; for(i=1;i&lt;400;i++)&#123; dp[i]=sum; sum+=dp[i]; &#125; return dp[number]; &#125;&#125;; 10我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 1234567891011121314class Solution &#123;public: int dp[400]; int rectCover(int number) &#123; int i; dp[1]=1; dp[0]=1; for(i=2;i&lt;400;i++)&#123; dp[i]=dp[i-1]+dp[i-2]; &#125; dp[0]=0; return dp[number]; &#125;&#125;; 11输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int m=32,cnt=0; while(m--) &#123; if(n&amp;1) cnt++; n&gt;&gt;=1; &#125; return cnt; &#125;&#125;; 12给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 1234567891011121314151617181920212223class Solution &#123;public: double Power(double base, int exponent) &#123; int ok=0; if(exponent&lt;0) &#123; exponent=-exponent; ok=1; &#125; if(exponent==0) return 1.0; if(exponent==1)&#123; if(ok==0) return base; else return 1.0/base; &#125; if(exponent&amp;1)&#123; if(ok==0) return base*Power(base,exponent/2)*Power(base,exponent/2); else return 1.0/(base*Power(base,exponent/2)*Power(base,exponent/2)); &#125; else &#123; if(ok==0) return Power(base,exponent/2)*Power(base,exponent/2); else return 1.0/(Power(base,exponent/2)*Power(base,exponent/2)); &#125; &#125;&#125;; 13输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 1234567891011121314class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; vector&lt;int&gt; odd; int i; for(i=0;i&lt;array.size();i++)&#123; if(array[i]&amp;1) odd.push_back(array[i]); &#125; for(i=0;i&lt;array.size();i++)&#123; if(!(array[i]&amp;1)) odd.push_back(array[i]); &#125; array=odd; &#125;&#125;; 14输入一个链表，输出该链表中倒数第k个结点。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; stack&lt;ListNode*&gt; sta; ListNode* t; int num; while(pListHead!=NULL)&#123; sta.push(pListHead); pListHead=pListHead-&gt;next; &#125; while(k)&#123; k--; num=sta.size(); if(num==0) return NULL; t=sta.top(); if(k==0) return t; sta.pop(); &#125; return NULL; &#125;&#125;; 15输入一个链表，反转链表后，输出新链表的表头。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode *t,*tt,*ret; if(pHead==NULL) return pHead; stack&lt;ListNode *&gt; sta; while(pHead!=NULL)&#123; sta.push(pHead); pHead=pHead-&gt;next; &#125; t=sta.top(); ret=t; sta.pop(); while(sta.size())&#123; tt=sta.top(); sta.pop(); t-&gt;next=tt; t=tt; &#125; t-&gt;next=NULL; return ret; &#125;&#125;; 16输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; ListNode *ret,*t,*res; queue&lt;ListNode *&gt; cur,curr; t=pHead1; while(t!=NULL)&#123; cur.push(t); t=t-&gt;next; &#125; t=pHead2; while(t!=NULL)&#123; curr.push(t); t=t-&gt;next; &#125; ret=NULL;res=NULL; while((cur.size())||(curr.size()))&#123; if(cur.size()) pHead1=cur.front(); if(curr.size()) pHead2=curr.front(); if(cur.size()); else &#123; if(res==NULL) res=pHead2; else &#123; res-&gt;next=pHead2; res=res-&gt;next; &#125; curr.pop(); if(ret==NULL) ret=res; continue ; &#125; if(curr.size()); else &#123; if(res==NULL) res=pHead1; else &#123; res-&gt;next=pHead1; res=res-&gt;next; &#125; cur.pop(); if(ret==NULL) ret=res; continue ; &#125; if(pHead1-&gt;val&lt;pHead2-&gt;val)&#123; if(res==NULL) res=pHead1; else &#123; res-&gt;next=pHead1; res=res-&gt;next; &#125; cur.pop(); if(ret==NULL) ret=res; continue ; &#125; else &#123; if(res==NULL) res=pHead2; else &#123; res-&gt;next=pHead2; res=res-&gt;next; &#125; curr.pop(); if(ret==NULL) ret=res; continue ; &#125; &#125; return ret; &#125;&#125;; 17输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 1234567891011121314151617181920212223242526272829303132/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSubTree(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot2==NULL) return 1; if(pRoot1==NULL) return 0; if(pRoot1-&gt;val==pRoot2-&gt;val)&#123; return isSubTree(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;isSubTree(pRoot1-&gt;right,pRoot2-&gt;right); &#125; else return 0; &#125; bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; int ok=0; if(pRoot2==NULL) return 0; if(pRoot1==NULL) return 0; if(pRoot1-&gt;val==pRoot2-&gt;val)&#123; ok|=(isSubTree(pRoot1-&gt;left,pRoot2-&gt;left)&amp;&amp;isSubTree(pRoot1-&gt;right,pRoot2-&gt;right)); &#125; ok|=HasSubtree(pRoot1-&gt;left,pRoot2); ok|=HasSubtree(pRoot1-&gt;right,pRoot2); return ok; &#125;&#125;; 18操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 123456789101112131415161718/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(pRoot==NULL) return ; swap(pRoot-&gt;left,pRoot-&gt;right); Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125;&#125;; 19输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int i,j,cnt,res; vector&lt;int&gt; t,ans; vector&lt;vector&lt;int&gt; &gt; vis; cnt=0; for(i=0;i&lt;matrix.size();i++)&#123; t.clear(); for(j=0;j&lt;matrix[i].size();j++)&#123; t.push_back(0); cnt++; &#125; vis.push_back(t); &#125; i=0;j=0;ans.clear();t.clear(); while(cnt&gt;t.size())&#123; while(j&lt;matrix[i].size())&#123; if(vis[i][j]==1) break; t.push_back(matrix[i][j]); vis[i][j]=1; j++; &#125; j--; i++; while(i&lt;matrix.size())&#123; if(vis[i][j]==1) break; t.push_back(matrix[i][j]); vis[i][j]=1; i++; &#125; i--; j--; while(j&gt;=0)&#123; if(vis[i][j]==1) break; t.push_back(matrix[i][j]); vis[i][j]=1; j--; &#125; j++; i--; while(i&gt;=0)&#123; if(vis[i][j]==1) break; t.push_back(matrix[i][j]); vis[i][j]=1; i--; &#125; i++; j++; &#125; return t; &#125;&#125;; 20定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526272829class Solution &#123;public: stack&lt;int&gt; cur,past; void push(int value) &#123; cur.push(value); if(past.size())&#123; int t=past.top(); if(t&gt;=value) past.push(value); &#125; else &#123; past.push(value); &#125; &#125; void pop() &#123; int t=cur.top(),tt=past.top(); cur.pop(); if(t==tt)&#123; past.pop(); &#125; &#125; int top() &#123; int t=cur.top(); return t; &#125; int min() &#123; int t=past.top(); return t; &#125;&#125;; 21输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 12345678910111213141516171819202122class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; int i,j; i=0;j=0; stack&lt;int&gt; sta; while(i&lt;pushV.size())&#123; sta.push(pushV[i]); i++; while(sta.size())&#123; int t=sta.top(); if(t==popV[j])&#123; sta.pop(); j++; &#125; else break; &#125; &#125; if(sta.size()) return 0; return 1; &#125;&#125;; 22从上往下打印出二叉树的每个节点，同层节点从左至右打印。 123456789101112131415161718192021222324252627/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; queue&lt;TreeNode *&gt; que; vector&lt;int&gt; ans; que.push(root); TreeNode *t; while(que.size())&#123; t=que.front(); que.pop(); if(t==NULL) continue ; ans.push_back(t-&gt;val); que.push(t-&gt;left); que.push(t-&gt;right); &#125; return ans; &#125;&#125;; 23输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 123456789101112131415161718192021222324class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; vector&lt;int&gt; res,ress; int D,i,ok; ok=1; if(sequence.size()==0) return 0; D=sequence[sequence.size()-1]; for(i=0;i&lt;sequence.size();i++)&#123; if(sequence[i]&lt;D) res.push_back(sequence[i]); else break; &#125; for(;i&lt;sequence.size();i++)&#123; if(sequence[i]&gt;D) ress.push_back(sequence[i]); else break; &#125; if(i+1==sequence.size()) &#123; if(res.size()) ok&amp;=VerifySquenceOfBST(res); if(ress.size()) ok&amp;=VerifySquenceOfBST(ress); return ok; &#125; return 0; &#125;&#125;; 24输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 12345678910111213141516171819202122232425262728293031323334353637383940414243/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; res; vector&lt;vector&lt;int&gt; &gt; ans; void dfs(TreeNode* root,int deep,int sum,int expectNumber)&#123; if(root==NULL)&#123; return ; &#125; if(sum&gt;expectNumber) return ; int len=res.size(); if(len==deep) res.push_back(root-&gt;val); else res[deep]=root-&gt;val; dfs(root-&gt;left,deep+1,sum+(root-&gt;val),expectNumber); dfs(root-&gt;right,deep+1,sum+(root-&gt;val),expectNumber); if((root-&gt;left==NULL)&amp;&amp;(root-&gt;right==NULL))&#123; if(sum+(root-&gt;val)==expectNumber)&#123; vector&lt;int&gt; t; for(int i=0;i&lt;=deep;i++)&#123; t.push_back(res[i]); &#125; if(t.size()) ans.push_back(t); &#125; return ; &#125; &#125; static int cmp(vector&lt;int&gt; A,vector&lt;int&gt; B)&#123; return A.size()&gt;B.size(); &#125; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; dfs(root,0,0,expectNumber); sort(ans.begin(),ans.end(),cmp); return ans; &#125;&#125;; 25输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; map&lt;RandomListNode *,int&gt; id; map&lt;int,RandomListNode *&gt; pos; RandomListNode *t,*head,*ret; int cnt; cnt=1; t=pHead; while(pHead!=NULL)&#123; id[pHead]=cnt++; pHead=pHead-&gt;next; &#125; pHead=t; head=NULL; ret=NULL; cnt=1; while(pHead!=NULL)&#123; if(head==NULL) head=new RandomListNode(0); if(ret==NULL) ret=head; head-&gt;label=pHead-&gt;label; pos[cnt]=head; cnt++; if((pHead-&gt;next)!=NULL)&#123; head-&gt;next=new RandomListNode(0); &#125; head=head-&gt;next; pHead=pHead-&gt;next; &#125; pHead=t; head=ret; while(pHead!=NULL)&#123; if((pHead-&gt;random)!=NULL) head-&gt;random=pos[id[pHead-&gt;random]]; pHead=pHead-&gt;next; head=head-&gt;next; &#125; return ret; &#125;&#125;; 26输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 这个题没做 27输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 1234567891011class Solution &#123;public: vector&lt;string&gt; Permutation(string str) &#123; sort(str.begin(),str.end()); vector&lt;string&gt; ans; do&#123; if(str[0]) ans.push_back(str); &#125;while(next_permutation(str.begin(),str.end())); return ans; &#125;&#125;; 28数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 123456789101112131415161718class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int n,len=numbers.size(),cnt,i,j; for(i=0;i&lt;5;i++)&#123; n=(rand()*rand())%len; cnt=0; for(j=0;j&lt;len;j++)&#123; if(numbers[j]==numbers[n])&#123; cnt++; &#125; &#125; if(cnt*2&gt;len) break; &#125; if(i&lt;5) return numbers[n]; else return 0; &#125;&#125;; 29输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 12345678910111213class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; ans; int len=input.size(); if(k&gt;len) return ans; sort(input.begin(),input.end()); for(int i=0;i&lt;k;i++)&#123; ans.push_back(input[i]); &#125; return ans; &#125;&#125;; 30HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 1234567891011121314class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int sum,i,ans; ans=array[0]; sum=0; for(i=0;i&lt;array.size();i++)&#123; sum+=array[i]; ans=max(ans,sum); if(sum&lt;0) sum=0; &#125; return ans; &#125;&#125;; 31求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 数位dp,懒得做 32输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: static int cmp(string s,string ss)&#123; return s+ss&lt;ss+s; &#125; string toS(int n)&#123; string s,ss; int cnt=0; while(n)&#123; s+=(n%10)+'0'; n/=10; cnt++; &#125; while(cnt)&#123; cnt--; ss+=s[cnt]; &#125; return ss; &#125; string PrintMinNumber(vector&lt;int&gt; numbers) &#123; vector&lt;string&gt; res; for(int i=0;i&lt;numbers.size();i++)&#123; res.push_back(toS(numbers[i])); &#125; sort(res.begin(),res.end(),cmp); string ans; for(int i=0;i&lt;res.size();i++)&#123; ans+=res[i]; &#125; return ans; &#125;&#125;; 33把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;int&gt; res; int GetUglyNumber_Solution(int index) &#123; res.push_back(1); int q,w,e,cnt,mx; q=w=e=0; cnt=0; mx=0; while(cnt&lt;index)&#123; if((res[q]*2&lt;=res[w]*3)&amp;&amp;(res[q]*2&lt;=res[e]*5))&#123; if(mx&lt;res[q]*2)&#123; mx=res[q]*2; res.push_back(res[q]*2); cnt++; &#125; q++; &#125; else if((res[w]*3&lt;=res[q]*2)&amp;&amp;(res[w]*3&lt;=res[e]*5))&#123; if(mx&lt;res[w]*3)&#123; mx=res[w]*3; res.push_back(res[w]*3); cnt++; &#125; w++; &#125; else &#123; if(mx&lt;res[e]*5)&#123; mx=res[e]*5; res.push_back(res[e]*5); cnt++; &#125; e++; &#125; &#125; return res[index-1]; &#125;&#125;; 34在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 1234567891011121314class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; int cnt[300]; memset(cnt,0,sizeof(cnt)); for(int i=0;str[i];i++)&#123; cnt[str[i]]++; &#125; for(int i=0;str[i];i++)&#123; if(cnt[str[i]]==1) return i; &#125; return -1; &#125;&#125;; 35在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: int tree[200005]; int lowbit(int x)&#123; return x&amp;(-x); &#125; void add(int x)&#123; while(x&lt;200005)&#123; tree[x]+=1; x+=lowbit(x); &#125; &#125; int sum(int x)&#123; int ans=0; while(x)&#123; ans+=tree[x]; x-=lowbit(x); &#125; return ans; &#125; int InversePairs(vector&lt;int&gt; data) &#123; vector&lt;int&gt; A; A=data; sort(A.begin(),A.end()); int i,mod=1000000007,ans=0; for(i=0;i&lt;data.size();i++)&#123; data[i]=(lower_bound(A.begin(),A.end(),data[i])-A.begin())+1; &#125; i=data.size(); memset(tree,0,sizeof(tree)); for(i--;i&gt;=0;i--)&#123; ans+=sum(data[i]); ans%=mod; add(data[i]); &#125; return ans; &#125;&#125;; 36输入两个链表，找出它们的第一个公共结点。 12345678910111213141516171819202122232425/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) &#123; map&lt;ListNode*,int&gt; ma; while(pHead1)&#123; ma[pHead1]=1; pHead1=pHead1-&gt;next; &#125; while(pHead2)&#123; if(ma[pHead2]==1)&#123; return pHead2; &#125; pHead2=pHead2-&gt;next; &#125; return NULL; &#125;&#125;; 37统计一个数字在排序数组中出现的次数。 12345678910class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int L=lower_bound(data.begin(),data.end(),k)-data.begin(); int R=upper_bound(data.begin(),data.end(),k)-data.begin(); if(L==data.size()) return 0; if(data[L]!=k) return 0; return R-L; &#125;&#125;; 38输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 12345678910111213141516171819202122232425/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int deep; void dfs(TreeNode* root,int de)&#123; if(root==NULL) return ; deep=max(deep,de); dfs(root-&gt;left,de+1); dfs(root-&gt;right,de+1); &#125; int TreeDepth(TreeNode* pRoot) &#123; deep=0; dfs(pRoot,1); return deep; &#125;&#125;; 39输入一棵二叉树，判断该二叉树是否是平衡二叉树。 12345678910111213141516class Solution &#123;public: int AVL(TreeNode* pRoot)&#123; int L,R; if(pRoot==NULL) return 0; L=AVL(pRoot-&gt;left); R=AVL(pRoot-&gt;right); if(L&gt;R) swap(L,R); if(L==-1) return -1; if((R-L&lt;=1) &amp;&amp; (R-L&gt;=0)) return R+1; else return -1; &#125; bool IsBalanced_Solution(TreeNode* pRoot) &#123; return AVL(pRoot)&gt;-1?1:0; &#125;&#125;; 40一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 1234567891011121314151617class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int x,A,B,i; A=B=x=0; for(i=0;i&lt;data.size();i++)&#123; x^=data[i]; &#125; x=(x&amp;(-x)); for(i=0;i&lt;data.size();i++)&#123; if(data[i]&amp;x) A^=data[i]; else B^=data[i]; &#125; *num1=A; *num2=B; &#125;&#125;; 41小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; int cnt,L,i,j; vector&lt;int&gt; res; vector&lt;vector&lt;int&gt; &gt; ans; L=1;cnt=0; for(i=1;i&lt;=sum;i++)&#123; while(cnt&gt;sum) &#123; cnt-=L; L++; &#125; if(cnt==sum)&#123; res.clear(); for(j=L;j&lt;i;j++)&#123; res.push_back(j); &#125; ans.push_back(res); &#125; cnt+=i; &#125; return ans; &#125;&#125;; 42输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; int ans,i,res,L,R,MX; vector&lt;int&gt; ret; ans=-1; L=0; R=array.size(); R--; MX=array[R]*array[R]; for(L=0;L&lt;R;L++)&#123; while(array[L]+array[R]&gt;sum) R--; if(array[L]+array[R]==sum)&#123; if(MX&gt;array[L]*array[R])&#123; ans=array[L]; MX=array[L]*array[R]; &#125; &#125; &#125; ret.clear(); if(ans==-1) return ret; ret.push_back(ans); ret.push_back(sum-ans); return ret; &#125;&#125;; 43汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 1234567891011121314151617class Solution &#123;public: string LeftRotateString(string str, int n) &#123; string ret; ret=""; if(str=="") return ret; int i,len=str.size();; n=n%len; for(i=n;str[i];i++)&#123; ret+=str[i]; &#125; for(i=0;i&lt;n;i++)&#123; ret+=str[i]; &#125; return ret; &#125;&#125;; 44牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 12345678910111213141516171819202122232425class Solution &#123;public: string ReverseSentence(string str) &#123; stack&lt;string&gt; sta; while(sta.size()) sta.pop(); int i; string res; res=""; for(i=0;str[i];i++)&#123; if(str[i]==' ')&#123; if(res!="") sta.push(res); sta.push(" "); res=""; &#125; else res+=str[i]; &#125; if(res!="") sta.push(res); res=""; while(sta.size())&#123; res+=sta.top(); sta.pop(); &#125; return res; &#125;&#125;; 45LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 123456789101112131415161718192021222324class Solution &#123;public: int judge(int beg,vector&lt;int&gt; numbers)&#123; int t,i,vis[20],cnt; memset(vis,0,sizeof(vis)); cnt=0; for(i=0;i&lt;numbers.size();i++)&#123; t=numbers[i]; if(t==0) cnt++; if(vis[t]==0 &amp;&amp; t&gt;=beg &amp;&amp;t&lt;=beg+4) cnt++; vis[t]++; &#125; if(cnt==5) return 1; return 0; &#125; bool IsContinuous( vector&lt;int&gt; numbers ) &#123; for(int i=1;i&lt;10;i++)&#123; if(judge(i,numbers)) return 1; &#125; return 0; &#125;&#125;; 46每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 123456789101112class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if(m==0) return -1; int s=0,i; for(i=2;i&lt;=n;i++)&#123; s=(s+m)%i; &#125; return s; &#125;&#125;; 47求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 12345678class Solution &#123;public: int Sum_Solution(int n) &#123; const int m=n+1,M=n; bool ans[m][M]; return sizeof(ans)&gt;&gt;1; &#125;&#125;; 48写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 12345678910111213141516171819202122class Solution &#123;public: int Add(int num1, int num2) &#123; int i,j; if(num1&lt;num2) swap(num1,num2); for(i=0;i&lt;32;i++)&#123; if((num2&gt;&gt;i)&amp;1)&#123; for(j=i;j&lt;32;j++)&#123; if((num1&gt;&gt;j)&amp;1)&#123; num1=num1^(1&lt;&lt;j); &#125; else &#123; num1=num1^(1&lt;&lt;j); break; &#125; &#125; &#125; &#125; return num1; &#125;&#125;; 49将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 12345678910111213141516171819202122232425class Solution &#123;public: int StrToInt(string str) &#123; int L=0,R=str.size()-1,ans,ok; for(L=0;str[L]==' ';L++); for(;str[R]==' ';R--); ok=0; if(str[L]=='+') L++; else if(str[L]=='-')&#123; ok=1; L++; &#125; if(L&gt;R) return 0; ans=0; for(;L&lt;=R;L++)&#123; if(str[L]&gt;='0'&amp;&amp;str[L]&lt;='9')&#123; ans*=10; ans+=str[L]-'0'; &#125; else return 0; &#125; if(ok) ans=-ans; return ans; &#125;&#125;; 50在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 123456789101112131415161718192021222324252627class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; int i,j; for(i=0;i&lt;length;i++)&#123; while(numbers[i]!=i)&#123; if(numbers[i]&lt;i)&#123; *duplication=numbers[i]; return 1; &#125; j=numbers[i]; if(j==numbers[j]) &#123; *duplication=numbers[i]; return 1; &#125; swap(numbers[i],numbers[j]); &#125; &#125; return 0; &#125;&#125;; 51给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法. 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int i,res; vector&lt;int&gt; B; res=1; for(i=0;i&lt;A.size();i++)&#123; B.push_back(res); res*=A[i]; &#125; res=1; for(i=A.size()-1;i&gt;=0;i--)&#123; B[i]*=res; res*=A[i]; &#125; return B; &#125;&#125;; 52请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 123456789101112131415161718192021222324class Solution &#123;public: bool match(char* str, char* pattern) &#123; if(!str[0]&amp;&amp;!pattern[0])&#123; return 1; &#125; if(str[0]&amp;&amp;!pattern[0])&#123; return 0; &#125; if(pattern[1]=='*')&#123; if((str[0]==pattern[0]) || (('.'==pattern[0])&amp;&amp;str[0]))&#123; return match(str,pattern+2)||match(str+1,pattern); &#125; return match(str,pattern+2); &#125; else &#123; if((str[0]==pattern[0]) || (('.'==pattern[0])&amp;&amp;str[0]))&#123; return match(str+1,pattern+1); &#125; return 0; &#125; &#125;&#125;; 53请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool isNumeric(char* string) &#123; int L=0,cnt=0,ok=0; if(string[L]=='+') L++; else if(string[L]=='-') L++; for(;string[L];L++)&#123; if(string[L]=='.') cnt++; if(cnt&gt;1) return 0; if(string[L]=='.') continue; if(string[L]&gt;='0'&amp;&amp;string[L]&lt;='9') continue ; break; &#125; if(!string[L]) return 1; if(string[L]=='E'||string[L]=='e')&#123; L++; ok=1; &#125; if(string[L]=='+') L++; else if(string[L]=='-') L++; cnt=0; for(;string[L];L++)&#123; if(string[L]=='.') return 0; if(string[L]&gt;='0'&amp;&amp;string[L]&lt;='9')&#123; cnt++;continue ; &#125; return 0; &#125; if(ok) &#123; if(cnt) return 1; return 0; &#125; return 0; &#125;&#125;; 54请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 1234567891011121314151617181920class Solution&#123;public: //Insert one char from stringstream int num[300]=&#123;0&#125;,L=0; vector&lt;int&gt; vec; void Insert(char ch) &#123; vec.push_back(ch); num[ch]++; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; while(L&lt;vec.size()&amp;&amp;num[vec[L]]&gt;1) L++; if(L==vec.size()) return '#'; return vec[L]; &#125;&#125;; 55给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 12345678910111213141516171819202122/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; map&lt;ListNode*,int&gt; ma; while(pHead)&#123; if(ma[pHead]==1) return pHead; ma[pHead]=1; pHead=pHead-&gt;next; &#125; return pHead; &#125;&#125;; 56在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; ListNode *ret,*t,*tt; int i; vector&lt;int&gt; vec; vector&lt;ListNode*&gt; vecR; vec.push_back(-999123); vecR.push_back(0); while(pHead)&#123; vec.push_back(pHead-&gt;val); vecR.push_back(pHead); pHead=pHead-&gt;next; &#125; vec.push_back(-999123); vecR.push_back(0); ret=NULL; for(i=1;i&lt;vec.size()-1;i++)&#123; if((vec[i]!=vec[i-1])&amp;&amp;(vec[i]!=vec[i+1]))&#123; if(ret==NULL)&#123; ret=vecR[i]; t=ret; t-&gt;next=NULL; &#125; else &#123; t-&gt;next=vecR[i]; t=vecR[i]; t-&gt;next=NULL; &#125; &#125; &#125; return ret; &#125;&#125;; 57给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 12345678910111213141516171819202122232425262728293031323334353637383940/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;TreeLinkNode *&gt; vec; void dfs(TreeLinkNode* now)&#123; if((now-&gt;left)!=NULL) dfs(now-&gt;left); vec.push_back(now); if((now-&gt;right)!=NULL) dfs(now-&gt;right); &#125; TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; TreeLinkNode *root; TreeLinkNode *t=pNode; int i; while(pNode!=NULL)&#123; root=pNode; pNode=pNode-&gt;next; &#125; vec.clear(); dfs(root); vec.push_back(NULL); for(i=0;i&lt;vec.size()-1;i++)&#123; if(vec[i]==t)&#123; return vec[i+1]; &#125; &#125; return NULL; &#125;&#125;; 58请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 123456789101112131415161718192021222324252627282930/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int same(TreeNode* L,TreeNode* R)&#123; if(L==NULL &amp;&amp; R==NULL) return 1; if(L!=NULL &amp;&amp; R==NULL) return 0; if(L==NULL &amp;&amp; R!=NULL) return 0; if((L-&gt;val)==(R-&gt;val))&#123; return same(L-&gt;left,R-&gt;right)&amp;&amp;same(L-&gt;right,R-&gt;left); &#125; else &#123; return 0; &#125; &#125; bool isSymmetrical(TreeNode* pRoot) &#123; if(pRoot==NULL) return 1; return same(pRoot-&gt;left,pRoot-&gt;right); &#125;&#125;; 59请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: struct node&#123; int deep; TreeNode* now; &#125;; vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; queue&lt;node&gt; que; vector&lt;vector&lt;int&gt; &gt; ans; vector&lt;int&gt; res,ress; stack&lt;int&gt; sta; node t,tt,L,R; t.now=pRoot; t.deep=0; que.push(t); int x; while(que.size())&#123; tt=que.front(); que.pop(); if((tt.now)==NULL) continue ; if((tt.deep)%2==0)&#123; while(sta.size())&#123; x=sta.top(); sta.pop(); res.push_back(x); &#125; if(res.size())&#123; ans.push_back(res); res.clear(); &#125; ress.push_back((tt.now)-&gt;val); &#125; else &#123; if(ress.size())&#123; ans.push_back(ress); ress.clear(); &#125; sta.push((tt.now)-&gt;val); &#125; L.deep=tt.deep+1; L.now=(tt.now)-&gt;left; R.deep=tt.deep+1; R.now=(tt.now)-&gt;right; if(L.now!=NULL) que.push(L); if(R.now!=NULL) que.push(R); &#125; if(ress.size())&#123; ans.push_back(ress); &#125; else &#123; while(sta.size())&#123; x=sta.top(); sta.pop(); res.push_back(x); &#125; if(res.size()) ans.push_back(res); &#125; return ans; &#125; &#125;; 60从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: struct node&#123; int deep; TreeNode* now; &#125;; vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; queue&lt;node&gt; que; vector&lt;vector&lt;int&gt; &gt; ans; vector&lt;int&gt; res,ress; stack&lt;int&gt; sta; node t,tt,L,R; t.now=pRoot; t.deep=0; que.push(t); int x; while(que.size())&#123; tt=que.front(); que.pop(); if((tt.now)==NULL) continue ; if((tt.deep)%2==0)&#123; if(res.size())&#123; ans.push_back(res); res.clear(); &#125; ress.push_back((tt.now)-&gt;val); &#125; else &#123; if(ress.size())&#123; ans.push_back(ress); ress.clear(); &#125; res.push_back((tt.now)-&gt;val); &#125; L.deep=tt.deep+1; L.now=(tt.now)-&gt;left; R.deep=tt.deep+1; R.now=(tt.now)-&gt;right; if(L.now!=NULL) que.push(L); if(R.now!=NULL) que.push(R); &#125; if(ress.size())&#123; ans.push_back(ress); &#125; if(res.size()) &#123; ans.push_back(res); &#125; return ans; &#125; &#125;;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Nice-Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞死小圆模板]]></title>
    <url>%2FGuass%2F</url>
    <content type="text"><![CDATA[高斯消元这个是在给定我们方程和未知数的时候常用的求解方式，原理很简单，就是最基本的LR分解的思想，在这里不再赘述。 需要注意的是其时间复杂度是$O(n^3)$。其中$n$表示的是未知数的个数。 数学上，高斯消元法（或译：高斯消去法），是线性代数规划中的一个算法，可用来为线性方程组求解。但其算法十分复杂，不常用于加减消元法，求出矩阵的秩，以及求出可逆方阵的逆矩阵。不过，如果有过百万条等式时，这个算法会十分省时。一些极大的方程组通常会用迭代法以及花式消元来解决。当用于一个矩阵时，高斯消元法会产生出一个“行梯阵式”。高斯消元法可以用在电脑中来解决数千条等式及未知数。亦有一些方法特地用来解决一些有特别排列的系数的方程组。 这里给出一份比较好用的模板： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// luogu2455#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;const int INF = 0x3f3f3f3f;const LL mod = 1e9 + 7;const int N = 505;const long double eps = 1e-8;// a是增广矩阵，n个方程，m个未知数，编号从0开始，最后方程的解为 a[i][m]// l[i]=true 表示x_i 为主元。// 返回秩，即线性空间的维度，-1 时无解，自由元有 m-dim 个。double a[N][N];bool l[N];int gauss(double a[][N], int n, int m) &#123; int dim = 0; for (int i = 0; i &lt; m; i++) l[i] = false; for (int i = 0; i &lt; m; i++) &#123; int t = dim; for (int j = dim; j &lt; n; j++) &#123; if (fabs(a[j][i]) &gt; fabs(a[t][i])) t = j; &#125; if (fabs(a[t][i]) &lt;= eps) continue; if (t != dim) swap(a[dim], a[t]); //化简出对角，该列除r行之外的行的该列为0 for (int j = 0; j &lt; n; j++) &#123; if (j != dim &amp;&amp; fabs(a[j][i]) &gt; eps) &#123; double tmp = a[j][i] / a[dim][i]; for (int k = i + 1; k &lt;= m; k++) &#123; a[j][k] -= tmp * a[dim][k]; &#125; a[j][i] = 0; &#125; &#125; l[i] = true; dim++; &#125; // dim行以后的常数项必须为0 for (int i = dim; i &lt; n; i++) &#123; if (fabs(a[i][m]) &gt; eps) return -1; &#125; if (dim &lt; m) return dim; //计算每个值，此时无自由元 for (int i = 0; i &lt; m; i++) &#123; a[i][m] /= a[i][i]; if (fabs(a[i][m]) &lt; eps) a[i][m] = 0; &#125; return dim;&#125;int main(void) &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; scanf("%lf", &amp;a[i][j]); &#125; &#125; int res = gauss(a, n, n); if (res == -1) &#123; puts("-1"); &#125; else if (res &lt; n) &#123; puts("0"); &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; printf("x%d=%.2f\n", i + 1, a[i][n]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Guass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kickstart-2019 Round B]]></title>
    <url>%2Fkickstart2019B%2F</url>
    <content type="text"><![CDATA[Round B这次笔试题的链接。还是蛮有意思的。 A题这个题目意思很简单，给我们一个串，之后给我们一个区间，问我们可以任意排列这个区间内的字符，问我们可不可以得到一个回文串。之后返回合法的区间个数。 想法我们对每个位置维护字母出现次数的前缀和，之后对于给定的区间。我们只需要作差之后。看奇数字符出现的种数就好了，因为偶数的我们可以左右一边放一个，奇数字符的种数最多只能有一个。这样我们就可以通过这道题目啦。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int cnt[100005][26];string s;int main(void)&#123; int i,j,n,m,T,l,r,ca=1,ans,res; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;m); cin&gt;&gt;s; for(i=0;i&lt;26;i++)&#123; cnt[0][i]=0; &#125; for(i=0;i&lt;n;i++)&#123; for(j=0;j&lt;26;j++)&#123; cnt[i+1][j]=cnt[i][j]; &#125; cnt[i+1][s[i]-'A']++; &#125; ans=0; for(i=0;i&lt;m;i++)&#123; scanf("%d %d",&amp;l,&amp;r); l--; res=0; for(j=0;j&lt;26;j++)&#123; if((cnt[r][j]-cnt[l][j])&amp;1) res++; &#125; if(res&lt;2) ans++; &#125; printf("Case #%d: %d\n",ca++,ans); &#125;&#125; B题有$n$种神奇的石头，每个石头都有其自己的价值$E_i$。不过石头大小不一，对于每一种石头，我们提取它的能量需要花费$S_i$秒，同时石头的能量是会流逝的，每一种石头每一秒流逝$L_i$点能量。我们在提取过程中石头不会继续损失能量。现在问我们如何提取这些石头可以使得我们获取的总能量最多？ 想法看到这个题目，我们很容易想到$DP$。因为结果明显是依赖你的决策顺序的，但是对于$DP$来说，我们只能确定一块石头提取或者不提取。并不能确定其具体在哪一时刻被提取。这样的话，我们就陷入了瓶颈。不过幸好出题人给了我们提示。他在小数据的时候说明了，每一块石头提取的时间相同，那么对于小数据而言，我们可以很快的确定每一块石头如果被利用的话，它所在的优先级是确定的，这却决于它的$L_i$。因为我们可以想到一个石头能量流逝的越快，那么它就应该越早被利用！但是对于每块石头消耗的时间不确定的时候呢？这个时候我们可以进行扩展。对于两块一定被利用的石头$A,B$，如果$A.sB.l&gt;B.sA.l$的话，说明$B$应该先被利用，因为这样总共损失的能量最少，这其实是一个很经典的想法。于是我们可以通过这种方式进行排序，得到石头被利用的顺序。之后再使用动态规划，确定其利用或者不利用。 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; int s,e,l;&#125;A[105];int dp[105][10005];//前i件，使用了j秒的最大结果int cmp(node A,node B)&#123; if(A.s*B.l&lt;B.s*A.l) return 1; return 0;&#125;int main(void)&#123; int i,j,n,m,T,ans,ca=1; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf("%d %d %d",&amp;A[i].s,&amp;A[i].e,&amp;A[i].l); &#125; sort(A+1,A+n+1,cmp); memset(dp,0,sizeof(dp)); ans=0; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;10005;j++)&#123; dp[i][j]=dp[i-1][j]; if(A[i].s&lt;=j)&#123; dp[i][j]=max(dp[i-1][j],dp[i-1][j-A[i].s]+max(0,A[i].e-A[i].l*(j-A[i].s))); dp[i][j]=max(dp[i][j],dp[i][j-1]); &#125; &#125; &#125; printf("Case #%d: %d\n",ca++,dp[n][10004]); &#125;&#125; C题给我们一个长度为$n$的序列，同时告诉我们每一种数的上限$m$。之后让我们可以任意选一个子区间，若这个区间内的某一种数出现的次数大于$m$，则舍弃。否则，就留下。问我们在任选区间的前提下，最多能剩下多少个数。 想法这个题目的构思十分巧妙，我们将原本的序列转换成前缀求和的形式，对于$n=6,m=2$时我们可以做下面的变换： \begin{eqnarray*} initialize \quad & 1，1，4，1，4，4 \\ new \quad & 1，2，3，1，2，0 \\ \end{eqnarray*}对于我们去掉左边一个$1$的时候。我们可以得到下面的结果 \begin{eqnarray*} initialize \quad & 1，4，1，4，4 \\ new \quad & 1，2，3，4，2 \\ \end{eqnarray*}这两个结果之间有着十分明显的相关性： 我们在删去最左边的数时，就可以再利用最进的一个贡献为0的相同数。 原本有贡献的位置答案都要-1 原本贡献结束的位置到新的位置之间+m 之后，我们使用线段树每次维护上面的操作，之后对于每个位置再查询最大值即可。对于区间更新，我们可以借助懒惰标记，实现$O(\log n)$的区间更新，和$O(\log n)$的区间最大值查询。那么总体的时间复杂度就是$O(n\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;int a[100005],cnt[100005],now[100005],lazy[100005&lt;&lt;2],MAX[100005&lt;&lt;2];vector&lt;int&gt; pos[100005];void pushup(int rt)&#123; MAX[rt]=max(MAX[rt&lt;&lt;1],MAX[rt&lt;&lt;1|1]);&#125;void pushdown(int rt)&#123; if(lazy[rt])&#123; lazy[rt&lt;&lt;1]+=lazy[rt]; lazy[rt&lt;&lt;1|1]+=lazy[rt]; MAX[rt&lt;&lt;1]+=lazy[rt]; MAX[rt&lt;&lt;1|1]+=lazy[rt]; lazy[rt]=0; &#125; return ;&#125;void build(int l,int r,int rt)&#123; if(l==r)&#123; MAX[rt]=now[l]; return ; &#125; int m=(l+r)/2; build(l,m,rt&lt;&lt;1); build(m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;void update(int L,int R,int v,int l,int r,int rt)&#123; if((l&gt;=L)&amp;&amp;(r&lt;=R))&#123; lazy[rt]+=v; MAX[rt]+=v; return ; &#125; pushdown(rt); int m=(l+r)/2; if(m&gt;=L) update(L,R,v,l,m,rt&lt;&lt;1); if(m+1&lt;=R) update(L,R,v,m+1,r,rt&lt;&lt;1|1); pushup(rt);&#125;int query(int L,int R,int l,int r,int rt)&#123; if((l&gt;=L)&amp;&amp;(r&lt;=R))&#123; return MAX[rt]; &#125; pushdown(rt); int m=(l+r)/2,res=0; if(m&gt;=L) res=max(res,query(L,R,l,m,rt&lt;&lt;1)); if(m+1&lt;=R) res=max(res,query(L,R,m+1,r,rt&lt;&lt;1|1)); return res;&#125;void kkk()&#123; vector&lt;int&gt; x; x.push_back(1); x.push_back(2); x.push_back(3); x.push_back(4); printf("%d\n",lower_bound(x.begin(),x.end(),3)-x.begin());&#125;int main(void)&#123; //kkk(); int i,j,n,m,T,POS,ans,ca=1; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;m); memset(cnt,0,sizeof(cnt)); memset(now,0,sizeof(now)); memset(lazy,0,sizeof(lazy)); memset(MAX,0,sizeof(MAX)); for(i=0;i&lt;100005;i++)&#123; pos[i].clear(); &#125; for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); pos[a[i]].push_back(i); if(cnt[a[i]]&lt;m) now[i]++; else if(cnt[a[i]]==m) now[i]-=m; now[i]+=now[i-1]; cnt[a[i]]+=1; &#125; for(i=1;i&lt;100005;i++)&#123; pos[i].push_back(n+1); &#125; build(1,n,1); ans=0; for(i=1;i&lt;=n;i++)&#123; ans=max(ans,query(i,n,1,n,1)); POS=lower_bound(pos[a[i]].begin(),pos[a[i]].end(),i)-pos[a[i]].begin(); if(pos[a[i]].size()&gt;(POS+m+1))&#123; update(pos[a[i]][POS],pos[a[i]][POS+m]-1,-1,1,n,1); update(pos[a[i]][POS+m],pos[a[i]][POS+m+1]-1,m,1,n,1); &#125; else &#123; update(i,n,-1,1,n,1); &#125; &#125; printf("Case #%d: %d\n",ca++,ans); &#125;&#125;]]></content>
      <categories>
        <category>GCJ</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫队算法]]></title>
    <url>%2FMo-algorithm%2F</url>
    <content type="text"><![CDATA[莫队算法莫队算法是一个十分优雅的暴力离线算法，发明人是前国家集训队队长莫涛，由于姓莫，然后是队长，所以叫做莫队算法啦，类似cdq(陈丹琦)分治、杜教筛这样的命名方式也是我国特色？这种算法用于给定一个序列，之后给定区间，要求我们返回区间的答案。莫队算法主要有三种分支，分别是普通莫队算法、带修改莫队算法、树上莫队算法，今天我们只讲普通莫队算法。既然是离线算法，那么就有一定的限制。以下是普通莫队算法的限制条件。 已知区间$[L,R]$的答案，我们可以$O(1)$的知道区间$[L+1,R]、[L-1,R]$、$[L+1,R+1]、[L,R-1]$​的答案。 只能有查询操作，不允许有修改操作。 需要离线可解，即每一次查询的结果是独立的。 莫队算法分析莫队算法的核心就是暴力。但是暴力也有很优雅的方式。我们对于所有的查询区间$[l_i,r_i]$。可以把它们看作二维平面上的一些点。之后根据上面的限制一，我们可以知道任意两个点进行转移的时间复杂度就是两个点的曼哈顿距离。于是我们总的时间开销就是遍历所有点的曼哈顿的距离的和，我们的想法就是找到一个查询节点遍历顺序，使得曼哈顿距离最小。有兴趣的可以参考这篇文章，这一步我们可以做到$O(n\log n)$。但是整个算法的瓶颈不在这个地方(我其实也不知道为什么，不过确实是有这个结论)，而在于就算我们找到了最小曼哈顿树，沿着这棵树走，我们还是需要$O(n\sqrt n)$ 的时间复杂度。于是整个算法的时间复杂度就是$O(n \sqrt n)$。 由于我们每一次求一个曼哈顿生成树的代码相对而言太长了(40+行)。于是我们通常在保证相同复杂度级别的情况下，找一个替代品。即我们并不需要每一次找一个最小距离曼哈顿生成树，而是找一个保证总时间复杂度级别不变的情况下，更好写的算法。 这个替代方法就是对序列分块，之后对于所有的查询按照$l_i$所在的块的大小排序，如果一样，再按照$r_i$的大小排序。这样做，找遍历的顺序的时间复杂度仍然不变，还是$O(n \log n)$，但是代码只需要6行。之后按照这样的排序方式进行计算就好了。但是这样为什么我们可以降低复杂度呢？我们可以简单的分析一下： $l_ i$与$l_{i+1}$在同一块内，$r_i$和$r_{i+1}$是单增的，由于$r$最多变化 $n$，那么这部分时间可以不计，由于$l$之间转移一次需要的时间最多为$\sqrt n$且这样的转移最多发生$n$次，所以这部分的时间复杂度是$n\sqrt n $ 。 $l_ i$与$l_{i+1}$不在同一块内，$r_i$和$r_{i+1}$不在同一块，由于$l,r$最多变化 $n$，且这种转移最多发生$\sqrt n$次。所以这个转移的时间复杂度是$n\sqrt n $ 等于说我们根据上面的结论，两种情况相加，复杂度仍然是$O(n\sqrt n)$ 模板下面给出莫队算法的模板，通过上面的分析，我们可以知道，我们只需要实现从$[L,R]$的答案是如何转移到$[L+1,R]、[L-1,R]$、$[L+1,R+1]、[L,R-1]$就可以了，相当于我们只需要实现从当前的区间加一个，答案如何变化，减去一个答案如何变化就好了。于是，我们使用普通莫队算法的时候几乎每次只需要修改add函数和del函数就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;int pos[50005],a[50005],flag[50005],ans[50005];struct node&#123; int L,R,id;&#125;Q[50005];int cmp(node A,node B)&#123; if(pos[A.L]==pos[B.L])&#123; return A.R&lt;B.R; &#125; return pos[A.L]&lt;pos[B.L];&#125;void add(int x)&#123;&#125;void del(int x)&#123;&#125;int main(void)&#123; //freopen("in.txt","r",stdin); int i,j,n,m,sz,L,R; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; sz=sqrt(n);//分块的个数 for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); pos[i]=i/sz; &#125; for(i=1;i&lt;=m;i++)&#123; scanf("%d %d",&amp;Q[i].L,&amp;Q[i].R); Q[i].id=i; &#125; sort(Q+1,Q+m+1,cmp); L=1;R=0;res=0; for(i=1;i&lt;=m;i++)&#123; while(L&lt;Q[i].L)&#123; L++; del(L-1); &#125; while(L&gt;Q[i].L)&#123; add(L-1); L--; &#125; while(R&lt;Q[i].R)&#123; R++; add(R); &#125; while(R&gt;Q[i].R)&#123; del(R); R--; &#125; // calculate answer ans[i]= &#125; for(i=1;i&lt;=m;i++)&#123; //print ans[i] &#125; &#125;&#125; BZOJ 2038 小Z的袜子-莫涛出的题目给出一个例子，其实就是修改了一下add函数和del函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;int pos[50005],a[50005],flag[50005];struct node&#123; int L,R,id;&#125;Q[50005];long long res,ansA[50005],ansB[50005];int cmp(node A,node B)&#123; if(pos[A.L]==pos[B.L])&#123; return A.R&lt;B.R; &#125; return pos[A.L]&lt;pos[B.L];&#125;void add(int x)&#123; res+=flag[a[x]]; flag[a[x]]++;&#125;void del(int x)&#123; flag[a[x]]--; res-=flag[a[x]];&#125;int main(void)&#123; //freopen("in.txt","r",stdin); int i,j,n,m,sz,L,R; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; memset(flag,0,sizeof(flag)); sz=sqrt(n); for(i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); pos[i]=i/sz; &#125; for(i=1;i&lt;=m;i++)&#123; scanf("%d %d",&amp;Q[i].L,&amp;Q[i].R); Q[i].id=i; &#125; sort(Q+1,Q+m+1,cmp); L=1;R=0;res=0; for(i=1;i&lt;=m;i++)&#123; while(L&lt;Q[i].L)&#123; L++; del(L-1); &#125; while(L&gt;Q[i].L)&#123; add(L-1); L--; &#125; while(R&lt;Q[i].R)&#123; R++; add(R); &#125; while(R&gt;Q[i].R)&#123; del(R); R--; &#125; ansA[Q[i].id]=res; ansB[Q[i].id]=(long long)(Q[i].R-Q[i].L)*(long long)(Q[i].R-Q[i].L+1)/2LL; &#125; for(i=1;i&lt;=m;i++)&#123; if(ansA[i]==0)&#123; printf("0/1\n"); &#125; else &#123; res=__gcd(ansA[i],ansB[i]); printf("%lld/%lld\n",ansA[i]/res,ansB[i]/res); &#125; &#125; &#125;&#125; 国际惯例https://www.bilibili.com/video/av4291097?from=search&amp;seid=17085351737729794960 https://blog.csdn.net/acmmmm/article/details/45724583]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Mo&#39;s-Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红蓝眼睛问题]]></title>
    <url>%2FRedBlue%2F</url>
    <content type="text"><![CDATA[问题背景一个与世隔绝的岛上住着一个原始部落，这个部落的人有两种颜色，一种是蓝色，一种是红色。岛上的有着绝对的宗教规定，如果一个人知道了自己的眼睛是蓝色，那么他就应该在当晚结果自己。 部落的人严格恪守这个禁忌，他们从不照镜子等反光设备同时也不会互相谈论眼睛的颜色。换句话说，他们没有任何途径得知自己的眼睛颜色。但是他们可以知道其他所有人的眼睛颜色。 有一天，一位探险家发现了这个岛，并取得了部落的完全信任。在一次篝火聚会上，他触犯了这个禁忌，他说他非常好奇为什么岛上的人有两种不同的眼睛颜色。于是他当场被结果了。。。。 现在，每个人都知道岛上存在两种颜色眼睛的事实。且每个人都具有极强的逻辑推理能力，请问这座岛上会发生什么事？ 推理这个问题看上去实在是完全没有头绪。。。我们还是和之前的想法一样，从小数据开始去思考这个问题。 我们令蓝眼睛的人数个数为$x​$。 $x=1$的情况如果$x=1$的时候，那么岛上只有一个人是蓝眼睛。由于这个人可以知道所有其他人的眼睛颜色且都是红色。那么这个人当晚就可以推断出自己的眼睛颜色是蓝色。于是这个人当晚就会结果自己。 $x=2$的情况如果$x=2​$ 的时候，那么第一个晚上，将不会有任何人结果自己，因为2名蓝眼睛的人都能看到有1名人有蓝眼睛。那么他将不确定自己的眼睛颜色是不是蓝色。 但是到了第二天，蓝眼睛的人将会立刻意识到自己的眼睛颜色。因为他看见的那名蓝眼睛的人晚上没有结果自己，说明他也看到了蓝眼睛颜色的人，而他看见的其他人的眼睛颜色全是红色。说明自己的眼睛颜色就是蓝色！于是，在第二晚，将会有2个人结果自己。。。 $x=3$的情况如果说$x=3$的时候，那么前两个晚上将不会有任何人结果自己，因为3名蓝眼睛的人都能看到有2名人有蓝眼睛。那么他将不确定自己的眼睛颜色是不是蓝色。 但是到了第三天，蓝眼睛的人将会立刻意识到自己的眼睛颜色。因为他看见的2名蓝眼睛的人晚上没有在第二晚结果自己，说明蓝眼睛颜色的人数大于2，而他只看见了2个蓝色眼睛的人。说明自己的眼睛颜色就是蓝色！于是，在第三晚，将会有3个人结果自己。。。 $x=i$的情况根据数学归纳法，我们可以知道如果存在$i$名蓝色眼睛的人，那么将会在第$i$晚蓝眼睛的人全部结果自己。。。。]]></content>
      <categories>
        <category>Wonder</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组]]></title>
    <url>%2FFenwickTree%2F</url>
    <content type="text"><![CDATA[树状数组本文并不会详细说明树状数组的原理，因为网上已经太多了，在此不再赘述。本文主要内容在于如何使用树状数组做加性操作。 本文我们只介绍只包含加法操作的三种不同情况的应用。 单点更新区间查询 区间更新单点查询 区间更新区间查询 基本的树状数组模板首先我们定义了几种操作 lowbit(x)操作，一个数取出其二进制位最高含1的位对应的值 add(pos,v)操作，第pos个位置的数加上v sum(pos)操作，计算1-pos这个区间所有数的和 写成代码就是下面这个样子： 123456789101112131415161718int tree[1000] //最多只有1000个位置，可以扩展int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;1000)&#123; tree[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0; while(x)&#123; res+=tree[x]; x-=lowbit(x); &#125; return res;&#125; 特别需要注意的是，树状数组的下标是从1开始的。 单点更新区间查询这是树状数组最基本的用法，树状数组最早提出来就是为了解决这一类问题。 我们在更新第$pos$个位置，更新的值为$value​$的时候直接按下面的方式调用就好了。 add(pos,value)我们在查询区间$[l,r]​$的时候，我们直接计算： sum(r)-sum(l-1)一个简单的例子： 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int tree[1000];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;1000)&#123; tree[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0; while(x)&#123; res+=tree[x]; x-=lowbit(x); &#125; return res;&#125;int main(void) &#123; int i; memset(tree,0,sizeof(tree)); for(i=1;i&lt;10;i++)&#123; add(i,i); &#125; for(i=1;i&lt;10;i++)&#123; cout&lt;&lt;sum(i)&lt;&lt;endl; &#125;&#125; 区间更新单点查询这个问题其实就是一种差分。其实这个就只稍微变了一点，我们只需要转换一下思路就好，我们每次查询的时候，只要计算一个数需要被加多少就好了。 于是我们在更新区间$[l,r]$，每个数增加$value$的话，我们的操作如下： add(l,value) \\ add(r+1,-value)我们在查询$pos$位置的值的时候，操作如下： sum(pos)一个简单的例子： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int tree[1000];int lowbit(int x)&#123; return x&amp;(-x);&#125;void add(int x,int v)&#123; while(x&lt;1000)&#123; tree[x]+=v; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0; while(x)&#123; res+=tree[x]; x-=lowbit(x); &#125; return res;&#125;int main(void) &#123; int i; memset(tree,0,sizeof(tree)); add(1,3); add(3,-3); add(2,5); add(9,-5); for(i=1;i&lt;10;i++)&#123; cout&lt;&lt;sum(i)&lt;&lt;endl; &#125;&#125; 区间更新区间查询考虑如果只维护差分数组，针对这个问题我们的解决办法也很简单，具体过程如下： 设原数组第$i$位的值为$a_i$，$d_i=a_i−a_{i−1}$，则有(这里认为$a_0=0$)： a_x=\sum_{i=1}^x d_i所以有： \sum_{i=1}^r=a_i=\sum_{i=1}^r\sum_{j=1}^id_j=\sum _{i=1}^r d_i(r-i+1)我们把上面的式子化简一下，有： \sum _{i=1}^r d_i(r-i+1)=(r+1)(\sum _{i=1}^rd_i)-\sum _{i=1}^ri\cdot d_i因此我们需要两个树状数组，一个维护 $\sum_{i=1}^rd_i$，另一个维护$\sum_{i=1}^r i \cdot d_i​$ 即可。 一个简单的例子： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int tree[1000],TREE[1000];int lowbit(int x)&#123; return x&amp;(-x);&#125;void _add(int x,int v)&#123; int res=x*v; while(x&lt;1000)&#123; tree[x]+=v; TREE[x]+=res; x+=lowbit(x); &#125;&#125;int sum(int x)&#123; int res=0,T=x; while(x)&#123; res+=(T+1)*tree[x]-TREE[x]; x-=lowbit(x); &#125; return res;&#125;#define add(l,r,v) (_add(l,v),_add(r+1,-v))int main(void) &#123; int i; memset(tree,0,sizeof(tree)); memset(TREE,0,sizeof(TREE)); add(1,3,5); add(2,5,2); for(i=1;i&lt;10;i++)&#123; cout&lt;&lt;sum(i)-sum(i-1)&lt;&lt;endl; &#125;&#125;/*5 7 7 2 2*/]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>BIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件随机场CRF简介]]></title>
    <url>%2FCRF%2F</url>
    <content type="text"><![CDATA[条件随机场这个东西用起来其实很简单。只是当初在学的时候从开始就跑偏了，查了一些博客使得自己越来越懵，并不懂得为什么这样做，同时也百思不得其解为什么神经网络在用的时候并没有看到特征模板之类的东西。本文力求尽量简单的介绍CRF，但是需要读者掌握一些先验知识，隐马尔可夫模型和viterbi算法，文本会简单提一下这些知识，但是详细的可以看我之前写的文章。 我们按照《An Introduction to Conditional Random Fields》这篇论文的思路来尽量理清楚图模型的发展历程。首先让我们从一张流传甚广的模型关系图开始，如下图中所示，隐马尔可夫模型与线性链条件随机场是一对 “生成-判别对”（generative-discriminative pair）。可以理解为它们是一对近亲，模型非常相似。 图模型 对于多变量概率分布，图模型拥有强大的表示和推导能力。通常有很多个变量的分布是难以直接统计刻画的，因为其十分耗费资源，例如$n$个二值变量的联合分布需要$2^n$个浮点数空间。 而图模型建模方式的优点是：多变量分布通常可以表示为一些局部函数（local functions）的乘积，而每个局部函数依赖于更小的变量子集。通过因子化（factorization）和条件独立性（conditional independence），使得复杂的多变量分布可以用少得多的参数进行刻画。 上面的内容确实有一些枯燥，但是理解这句话会对接下来的阅读有很大的帮助： 有向图模型是一系列概率的连乘形式，无向图模型则是一系列函数的连乘形式。 这也是有向图模型一般用于表示生成式模型，而无向图模型一般表示判别式模型的原因之一。 而模型中的概率或函数是如何得到或定义的，则是非常有意思的地方，有时甚至也能通过巧妙的定义将有向图模型与无向图模型相互转换。 无向图模型考虑一组随机变量$Y$的概率分布，每个变量使用$Y_1,Y_2,…,Y_n$进行编号，其值可以是连续值或者离散值。同时令图的一组取值为$y_1,y_2,..,y_n$，且取值集合为$\Omega$。 假设概率分布$p(y_1,y_2,…,y_n)$可以表示为局部函数$\Psi _a(y_a)$的因子的乘积的形式，其中$1&lt;=a&lt;=A$是一个用于标记因子的整数，$A$表示的是最大团的个数，每一个因子$\Psi _a(y_a)$都只依赖于一个随机变量子集$Y_a \subseteq Y$，注意这里每一个$Y_a$不一定都只包含两个顶点，其中$Y_a$是一个最大团，表示任何两个点之间都有边相连。使用这种形式，我们可以高效的计算概率分布$p(y_1,y_2,…,y_n)​$。 对于这个例子的话，我们的结果就是: p(y_1,y_2,y_3)=Z^{-1}\Psi_1(y_1,y_2)\Psi_2(y_2,y_3)\Psi_3(y_1,y_3)=Z^{-1}\prod_{a=1}^A\Psi_ay_a\\ Z=\sum_Y^\Omega \prod _{a=1}^{A}\Psi_ay_a\tag{1.1}其中$Z$为归一化因子，计算起来就是遍历所有的$\Omega$ ，对每一种情况都计算概率再求和即可。 上面仅仅是一个简单的例子，其中节点可以无限扩展，只要最后的结果满足上述形式的无向图模型就被称为随机场（random field）。 通过这个例子，我们再回过头看看那句话，无向图模型则是一系列函数的连乘形式。 有向图模型 在无向图模型中，局部函数看起来并不是概率，也没有直观的概率解释，整个图模型更像是一顿函数计算后的结果。而有向图模型却是描述了一个分布是如何被因子化为局部条件分布（local conditional distributions）的。 在无向图模型中，局部函数看起来很奇怪，函数的结果也没有什么限制，这样的话和概率也就没什么关系了。但是有向图比无向图的解释性要好很多。假设我们得到了一个有向无环图(DAG，directed acyclic graph)$G$，其中$\pi_s$为$Y_s$的父节点集合，等于说我们在计算概率分布的时候可以使用下面的式子。 p(y_1,y_2,...,y_n)=\prod_{s=1}^Sp(y_s|\pi_s)\tag{1.2}我们称$p(y_s|\pi_s)$为局部条件概率分布，若$\pi_s$为空集的话，那么应该理解为$p(y_s)$，就直接是一个先验概率了。 有向图模型是一系列概率的连乘形式。 隐马尔可夫模型-HMM隐马尔可夫模型是一种常见的用于序列标注的传统算法，我们对观察序列$X(x_1,x_2,..,x_n)$和对应的隐状态序列$Y(y_1,y_2,…,y_n)$进行建模，同时假设$S$为有限的隐含状态集，$O$为有有限的观测状态集。隐马尔可夫模型做了三个假设，分别是： 状态构成一个隐马尔可夫链 不动性假设 输出独立性假设 通过这三个假设，我们可以把HMM写成： p(y,x)=\prod_{t=1}^Tp(y_t|y_{t-1})p(x_t|y_t)\tag{1.3}其中$p(y_t|y_{t-1})$ 是转移概率，发射概率$p(x_t|y_t)$。将隐马尔可夫模型用有向图表示为： 借鉴无向图的定义，我们可以构造局部函数$\Psi$使得隐马尔可夫模型巧妙地变成无向图。 p(y,x)=Z^{-1}\prod _{t=1}^T\exp \{\sum_{i,j\in S}\theta_{ij}1_{\{y_t=i\}}1_{\{y_{t-1}=j \}}+\sum_{i\in S}\sum_{o\in O} \mu_{oi} 1_{\{y_t=i\}}1_{\{x_t=o \}} \}\tag{1.4}其中： \theta_{ij}=\ln p(y=i|y'=j) \\ \mu_{oi}=\ln p(x=o|y=i) \\ Z=1线性链条件随机场我们通过$(1.4)$的推导，写出了HMM的无向图表示，但是上面的表示太麻烦了，我们进一步引入特征函数(feature function)来表示上面的冗长的式子。 令$\theta={\theta_{ij},\mu_{oi}}$ 表示参数，同时定义特征函数$f_k(y_t,y_{t-1},x_t)​$，显然我们需要两种特征函数 转移特征函数：$f_{ij}(y,y’,x)=1_{\{y=i\}}1_{\{y’=j\}}​$ 状态特征函数/发射特征函数：$f_{oi}(y,y’,x)=1_{\{y=i\}}1_{\{x=o\}}$ 我们将上述两种特征统一称为$f$，参数统称为$\theta​$ ，于是我们可以把HMM化简得到下面的形式: p(y,x)=Z^{-1}\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},x_t)\}\tag{1.5}接下来我们再引入归一化因子： \begin{eqnarray} p(y,x)&& =Z^{-1}\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},x_t)\}\\ && =\frac{\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},x_t)\}}{\sum_{y}^\Omega\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},x_t)\}} \end{eqnarray}\tag{1.6}上式就是一种特别的线性链条件随机场，特征函数仅使用当前词和前一结果作为参数，称为类HMM线性链条件随机场（HMM-like linear chain CRF）。但是其他许多类型的线性链条件随机场在输入上有丰富的特征，例如词的前缀、后缀、周围词等等。这些扩展需要对特征函数进行适当的改动，以获得更丰富的特征。 一般情况下的线性链条件随机场 令$X,Y$为随机变量，$\theta=\{\theta_k\}\in R^k$为参数向量，$F=\{f_k(y,y’,x)\}_{k=1}^K$是一组实值特征函数。一般情况下的线性链条件随机场即为如下形式的条件分布： p(y,x)=Z^{-1}\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},X)\}\tag{1.7}可以看到我们仅仅改了一点点地方，就是最后的$x_t$改成了$X$。相当于我们每次传入了所有的词。画出图来也就是下面这样。 特征函数需要具体问题具体设计，我们可以根据自己的需要去传相应的参数。 到此为止，我们已经把线性链CRF说明了。其实对比HMM，就是一个有向图到无向图的转换过程。是不是感觉很玄学。下面我们将介绍具体的应用场景。 序列标注问题据我所知，条件随机场的应用场景大多都在序列标注问题中，针对这一类问题，我们可以形式化的表示出来为如下形式，给定一组查询$X$，我们希望得到与这一组相同维度大小的标注信息$y_1,y_2,…,y_n$： \begin{equation} P(y_1,y_2,...y_n|X) \tag{2.1} \end{equation}但是不管是使用传统的方法还是深度学习的方法，直接对上面的问题建模都太难了。于是这里和隐马尔可夫模型的思想一样，我们对其做一些假设，比如我们认为每个标签都只与其自身的特征向量相关，于是我们可以将上面的公式化简为： P(y_1,y_2,...,y_n|X)=P(y_1|x_1)P(y_2|x_2)...P(y_n|x_n) \tag{2.2}请注意这里的$x_i$并不一定是原始查询的词向量，也可以是经过bi-LSTM或者CNN提取的特征向量，我们可以认为通过前面的模型我们已经获取到了全局的上下文信息$x_i$，从而对于每一个特征向量单独对其进行标注。 逐标签softmax模型通过上面的假设，我们可以发现每一组$P(y_i|x_i)​$都是独立的。根据这样的思想，我们可以设计一个最简单的模型，给定$x_i​$输出其对应的概率最大的标签。也就是逐标签softmax模型。但是这样的模型显然太粗糙了，虽然说通过LSTM和CNN考虑到了全文本的信息，但是这往往还是会出现一些非法标注的情况，以4tag标签$SBME​$为例： S 单个的词/字(single-word) B 词/字的开始标签(begin-word) M 词/字中间的单词标签(middle-word) E 词/字的结束标签(end-word) 我们很有可能会出现$EE、BS、SME$这样的非法标注。所以我们仅仅依靠编码层提取的信息保证不出现上面的情况确实太难了。 神经网络中的线性链条件随机场简单来说，上述的模型的根本问题就是我们没有考虑到前面预测的标签的结果，于是我们需要再考虑上文的标签信息： P(y_1,y_2,...,y_n|X)=P(y_1|x_1)P(y_2|x_2,y_1)...P(y_n|x_n,y_1,y_2...,y_{n-1})\tag{2.3}同时我们再做进一步的假设，当前的标签只和前一步的标签相关，这也就是为什么称为链的原因： P(y_1,y_2,...,y_n|X)=P(y_1|x_1)P(y_2|x_2,y_1)...P(y_n|x_n,y_{n-1})\tag{2.4} 我们把上面的式子打开： P(y_1|x_1)P(y_2|x_2,y_1)...P(y_n|x_n,y_{n-1})=P(y_1|x_1)P(y_2|x_2)P(y_2|y_1),...,P(y_n|x_n)P(y_n|y_{n-1})这其实和隐马尔可夫模型的推导是一模一样的！但是唯一的不同点在于发射概率的不同，HMM是$P(x_i|y_i)​$，但是这里是$P(y_i|x_i)。​$ 传统的隐马尔可夫模型其中的$P(y_i|y_{i-1})$其实就是$A$矩阵对应的转移概率，$P(x_i|y_i)$对于的就是$B$矩阵的发射概率。在之前我们使用极大似然估计来统计$A,B$的值。关于这里的$A,B$，详细的信息请看本文。而在神经网络中我们做了少许变换，其中$A$变成了我们要学习的参数矩阵，但是CRF中$B$矩阵和之前不一样了！但是幸运的时候我们可以使用上述的$x_1,x_2,…,x_n$的特征向量的矩阵替换原来的$B​$达到一样的效果。写成公式可以表示成下面的样子： score(X,y)=\sum_{t=0}^{n}A_{y_t,y_{y+1}}+\sum_{t=0}^{n}B_{t,y_t}\\ P(y|X)=\frac{exp(score(X,y))}{\sum_{y'}exp(score(X,y'))}\\换句话说，HMM里面的发射概率在这里换成了是我们通过神经网络取到的特征向量$x_i$。只有$A$矩阵是我们要学习的参数矩阵，$A​$这个标签迁移矩阵其实学习起来参数并不多，就这个问题来说，迁移矩阵只有4*4=16个参数。特征函数也只有2*4*4=32个参数。 如果说你对隐马尔可夫模型熟悉的话，那么对这个图肯定是再熟悉不过了！这其实就是使用viterbi算法进行解码，找到最大概率的路径！对于分词任务来说，正确的答案一般都是唯一的，例如“电脑电源坏了”，分词结果应该是”电脑/电源/坏/了”，对应的答案就是bebess。也就是对应上面的一条路径。 到此为止，我们应该可以发现，对于4tag任务来说，使用crf和传统的逐步softmax方法的最大的不同之处就是：前者将序列标注看成是$n​$个$4​$分类问题，后者将序列标注看成是$1​$个$4^n​$分类问题。同理我们可以扩展到k-tag任务。 训练方法为了训练crf模型，我们和之前的HMM模型一样，使用最大似然的思想，也就是说我们最小化损失函数： -\log p(y_1,y_2,...,y_n|X)\tag{2.5}现在我们再次召唤式$(1.5)​$： p(y,x)=Z^{-1}\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},x_t)\}根据前面的分析，我们有两种特征函数，为了更方便的进行推导，我们进行如下改动。 转移特征函数：$f_{ij}(y,y’,x)=1_{\{y=i\}}1_{\{y’=j\}}​$ 我们将$\theta_kf_{ij}(y,y’,x)​$融合为$g(y,y’)​$ 状态特征函数/发射特征函数：$f_{io}(y,y’,x)=1_{\{y=i\}}1_{\{x=o\}}$，注意我们为了和CRF的计算公式保持一致，这里把$oi$改成了$io​$ 我们将$\theta_kf_{io}(y,y’,x)​$ 融合为$h(y,x)​$ 于是我们有下面的推导： \begin{eqnarray} p(y,x) && =Z^{-1}\prod_{t=1}^T\exp\{\sum_{k=1}^K\theta_kf_k(y_t,y_{t-1},x_t)\}\\ && = Z^{-1}\prod_{t=1}^T\exp\{h(y_1,x_y)+g(y_2,y_1)+h(y_2,x_2)+...,+g(y_n,y_{n-1})+h(y_n,x_n)\} \end{eqnarray}\tag{2.6}根据式$(2.5)$，我们可以写出我们最终的损失函数： -(h(y_1,x_1)+\sum_{k=2}^{n}\{g(y_k,y_{k-1})+h(y_k,x_k)\})+\log Z\tag{2.7}其中$h(y_i,x_i)$是我们的通过bi-LSTM或者CNN等提取到的特征向量的$x_i$第$y_i$维，也就是$x_{i,y_i}$。同时$g$是我们需要求解的转移特征矩阵。换句话说，前面一大堆的东西算起来特别简单，我们计算的困难是$\log Z$。 归一化因子，$Z$，在物理上也叫配分函数，在这里它需要我们对所有可能的路径的打分进行指数求和，而我们前面已经说到，针对k-tag这样的问题，路径数是指数量级的$k^n$ ，因此直接来算几乎是不可能的啦。事实上，归一化因子难算，几乎是所有概率图模型的公共难题。 不过，这里是crf，我们做了类似隐马尔可夫模型的一阶假设，我们和类似HMM评估问题的做一样的操作，等于说我们每次都只考虑相邻的k个节点就好了。因此我们可以递归的计算出归一化因子，这使得原来是指数级的计算量降低为线性级别。具体来说，我们将计算到时刻$t$的归一化因子记为$Z_t$，并将它分为$k$个部分。 Z_t=Z_t^{(1)}+Z_t^{(2)}+...+Z_t^{(k)}且我们有： Z_{t+1}^{(i)}=\{Z_t^{(1)}G_{1i}+Z_t^{(2)}G_{2i}+...+Z_t^{(n)}G_{ni}\}*H_{t+1}(i|x)\tag{2.7}可以写为矩阵相乘的形式： Z_{t+1}=Z_tG⊗H(y_{t+1}|x)\tag{2.8}其中$Z_t=[Z_t^{(1)},…,Z_t^{(k)}]$；而$G$是对矩阵$g$各个元素取指数后的矩阵（代表某个标签到另一个标签的分数），即$G_{ij}=e^{g_{ij}}$；而$H(y_{t+1}|x)$是编码模型$h(y_{t+1}|x)$（LSTM、CNN等）对位置$t+1$的各个标签的打分的值，即$H(y_{t+1}|x)=e^{h(y_{t+1}|x)}$，也是一个向量。式$(2.8)$中，$Z_tG$这一步是矩阵乘法，得到一个向量，而$⊗​$是两个向量的逐位对应相乘。 最后我们将$\sum_i^kZ_n^{(i)}​$的值全部相加再取log就可以得到我们的归一化因子了。 到此为止，我们已经知道了如何计算损失函数，那么通过反向传播算法，我们就可以对整个crf进行训练。同时我们在解码的时候需要使用viterbi算法进行解码。具体过程和HMM算法是一样的。 国际惯例果壳中的CRF CRF的keras实现 线性链CRF解释]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>crf</tag>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有意思的游戏]]></title>
    <url>%2FSimpleGame%2F</url>
    <content type="text"><![CDATA[博弈博弈主要分为3类： 负和博弈，也就是两败俱伤。 零和博弈，也就是一方获利一方亏损。 正和博弈，也就是双赢。 正和博弈当然是最好的结果，但是往往很少出现这样的情况。 囚徒困境-负和博弈故事是这样的，有两个人A,B入室盗窃，且杀死了房屋的主人。他们被抓起来后，假如两人都咬定自己只有盗窃，但没有故意杀人的话，那他们两个都只会坐一年的牢。但是实际情况往往是两人都会承认故意杀人罪，这是为什么呢？ 我们可以用下面的表来表示这个问题。 B承认 B不承认 A承认 (8,8) (0,10) A不承认 (10,0) (1,1) 我们可以看到四种情况： A、B都承认，两个人都坐8年的牢 A承认，B不承认。A无罪释放，B坐10年的牢 A不承认，B承认。A坐10年的牢，B无罪释放 A、B都不承认。A、B两个人都坐1年的牢。 想法显然，我们可以看到都不承认是最优解，都承认是最坏解。但是实际上往往发生的是最坏的解。原因很简单：每个人都是自私的。因为对个人而言，坐10年牢是最坏解。在避免最坏解坐10年牢，个人承认的情况下，个人最多只坐8年牢，同时还有机会无罪释放。承认的好处对于个人而言是极其具有诱惑性的。 简单来说，就是至少一方必须进行违反自己利益的选择，才能使整体获得最优解。否则最后的结果往往走向的是负和博弈。 弱者生存问题故事是这样的，三个枪手进行一场决斗，但是枪手之间会有一些区别，根据命中率排序的话，我们暂且称为上等马、中等马、下等马，假设他们的命中率分别为80%,60%,40%。 问题一我们现在考虑一个问题，他们每个人都会有一发子弹，同时开枪的话，谁的生存概率最大？ 想法 对于上等马而言，他瞄准的肯定是中等马，因为他必须杀死对他威胁最大的人。 对于中等马而言，他瞄准的肯定是上等马，因为他必须杀死对他威胁最大的人。 对于下等马而言，他瞄准的肯定是上等马，因为他必须杀死对他威胁最大的人。 上面的选择都是对自己最有利的。我们可以看到： 最强的上等马往往树敌最多，存活率只有24%。 最弱的下等马往往不会死，存活率是100%！ 问题二我们现在再考虑一个问题，他们每个人都会有一发子弹，上等马中等马下等马轮流开枪的话，谁的生存概率最大？ 想法 上等马先开枪会如何呢？ 首先肯定打中等马，如果没杀死的话，中等马自然会向上等马开枪，全程下等马可以毫发无埙。这时，下等马再拿起枪，瞄准剩下的一个目标，（或者两个目标都活着的话就朝天）开一枪，娱乐一下，存活率下等马仍然是最大的。so easy！ 中等马先开枪会如何呢？ 中等马会把枪口对准对他更具有威胁的上等马，下等马不会有危险，如果它命中了，下等马就向中等马开枪，没打中就朝上等马开枪，最后下等马的存活率仍然是最大的。so easy! 下等马先开枪会如何呢？ 这是一个很难受的问题，下等马该先向谁开枪呢？打上等马？没打中还好，会转化成上等马先开枪的情况（也难保它不记仇呀），万一RP不足手抖打中了呢，那就只剩下下等马和中等马两人了，中等马一定会朝我开枪了,那下等马可就很危险了呀！不行不行，下等马可不能这么草率。那么如果朝中等马开枪呢？那也是一样的，打中了反而会使自己置于更加危险的境地，因为上等马的命中率更高。打谁都不是，那么该怎么办呢？结论是：朝天开枪。这确实很滑稽…..但也是最有效的方法，能够让情况变为上等马先开枪。下等马的生存概率依然是最大的！so easy! 其实这个问题现实中往往很常见，我们耳熟能详的三国其实就是这种情况，下等马刘备往往是最难灭的。因为上面无论哪种情况，下等马的存活概率都是最高的。现在想想，诸葛亮真是神机妙算！三国时期的赤壁之战，刘备最弱，孙权其次，曹操最强，曹操要和孙权干架，诸葛亮的想法是：二虎相争，必有一伤，如果曹操输了必定一蹶不振，孙权就会向刘备开刀，如果孙权被灭，曹操也必定会攻打刘备。这时刘备帮助较弱的孙权，将曹操打败，但是又“一不小心”让关羽把曹操在华容道放掉了，以达到制衡的目的。 海盗分金币问题故事是这样的，5个海盗抢了100个金币，准备分，但是他们分的方法非常奇特。他们准备了5个签，分别写上1,2,3,4,5，然后抽签，按抽签顺序（从小到大）轮流制定方案，从1号开始，他制定了分金方案后大家需要立即表决（该海盗也表决），如果有半数以上（含半数）的人支持，则方案通过，按此方案分金，否则就会被扔到海里喂鲨鱼。。。。 乍一看，抽签的第一个海盗简直是太惨了，几乎是必定要去喂鲨鱼了，因为他貌似无论做什么决策都要去味鲨鱼了，因为他死了，分母就变小了，期望就变大了。同时最后一个海盗好安全啊！好像无论如何都能拿到金币！ 想法我们需要注意一个关键的地方：如果有半数以上（含半数）的人支持，则方案通过。等于说我们并不需要每个人都分金币，我们只需要拉拢部分人就行了！我们先考虑简单一点的情况。 最后只剩下2个海盗，编号为4,5 那我只需要指定(100,0)这样的方案就行了，因为制定计划的人算一票。等于说这时候，5号是无论如何都拿不到金币的！这么看来，5号看似安全，但是实际上他很有可能拿不到金币！ 最后只剩下3个海盗，编号为3,4,5 根据上面的分析，我去喂鲨鱼了，5号一个金币都拿不到，那我现在只需要拉拢5号就行了鸭！等于说我现在给钱他就能同意。那么我制定(99,0,1)这样的情况我就能大捞一笔了！ 最后剩下4个海盗，编号为2,3,4,5 根据上面的分析，4号是最弱势的，我现在只要拉拢他就行了鸭！那么我制定(99,0,1,0)这样的方案就完事了。 最初的情况，编号为1,2,3,4,5 根据上面的分析，现在3号，5号弱势，我现在拉拢他俩就完事了鸭！那么我制定(98,0,1,0,1)这样的方案就完事了。虽然这样大概率就和鲨鱼见面了 根据上面的分析：看似最危险的一号貌似也没有那么危险了，反而可以化险为夷大捞一笔！看似最安全的5号却有很大可能一分钱都拿不到！ 国际惯例简单食用的博弈论]]></content>
      <categories>
        <category>Wonder</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相邻的数不同的方案数]]></title>
    <url>%2FDifferentWithNeighborhood%2F</url>
    <content type="text"><![CDATA[题意给定我们一个残缺的数组$A$，数组中的每个数要么为$-1$，要么小于等于$m$，我们可以使用$1-m$的数来填充原本为数组值为$-1$的位置。问我们有多少种不同的填法使得数组中任意相邻两个数不相同。 分析这个题目直接上并不好计算，但是我们可以经过一些处理来得到以下几种情况： $-1,-1,-1,…,-1,-1,-1$ $a,-1,-1,-1,…,-1,-1$和$-1,-1,-1,…,-1,-1,a$ $a,-1,-1,-1,…,-1,-1,-1,a$ $a,-1,-1,-1,…,-1,-1,-1,b$且$a != b​$ 对于上面的四种情况我们分别进行考虑。 对于第一种情况，假如$-1$的长度为$l$的话，我们的答案很简单： m*(m-1)^{l-1}对于第二种情况，假如$-1$的长度为$l$的话，我们的答案就更简单了： (m-1)^{l}但是对于第三种和第四种情况我们应该怎么计算呢？其实我们可以采用动态规划的思想来解决这两种情况。 我们考虑第三种情况下,$-1$的长度为$i$的解为$SAME[i]$ 我们考虑第四种情况下,$-1$的长度为$i$的解为$DIFF[i]$ 那么对于第三种情况下我们可以这样分析。 当$l$为奇数的时候，我们固定中间的那个$-1 $，则有递推式： SAME[l]=SAME[l/2]^2+(m-1)*DIFF[l/2]^2当$l$为偶数的时候，我们固定最左边的那个$-1$，则有递推式： SAME[l]=(m-1)*DIFF(l-1)相似的，那么对于第四种情况下我们可以这样分析： 当$l$为奇数的时候，我们固定中间的那个$-1 $，则有递推式： DIFF[l]=(m-2)*DIFF[l/2]^2+2*DIFF[l/2]*SAME[l/2]当$l$为偶数的时候，我们固定最左边的那个$-1$，则有递推式： DIFF[l]=(m-2)*DIFF(l-1)+SAME[l-1]由于$l$最大等于$n$，所以我们上述的初始化的时间为$O(n)$。且我们在解的时候只需要统计$-1$的分段个数就好了，这部分的复杂度也是$O(n)$。 所以这个问题我们可以通过$O(n)$的时间复杂度做完。 EduCF62E感兴趣的可以尝试做一下这个题目。以下是我的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include&lt;bits/stdc++.h&gt;using namespace std;long long DPDIFF(int x);vector&lt;int&gt; even,odd;long long DIFF[200005],SAME[200005],MOD=998244353,m;long long qp(long long x,long long T)&#123; long long res=1,t=x; while(T)&#123; if(T&amp;1)&#123; res*=t; res%=MOD; &#125; t*=t; t%=MOD; T&gt;&gt;=1; &#125; return res;&#125;long long ANS(vector&lt;int&gt; x)&#123; vector&lt;int&gt; same,unsame,bound; long long res=1,i,pre,cnt,t; pre=-2;cnt=0; same.clear(); unsame.clear(); bound.clear(); for(i=0;i&lt;x.size();i++)&#123; if(x[i]==-1) cnt++; else&#123; if(i&amp;&amp;x[i]==x[i-1])&#123; return 0; &#125; if(cnt)&#123; if(pre==-2)&#123; bound.push_back(cnt); &#125; else if(pre==x[i])&#123; same.push_back(cnt); &#125; else &#123; unsame.push_back(cnt); &#125; &#125; pre=x[i]; cnt=0; &#125; &#125; if(cnt)&#123; bound.push_back(cnt); &#125; if(pre==-2)&#123; return (m*qp(m-1,cnt-1))%MOD; &#125; for(auto t : bound)&#123; res*=qp(m-1,t); res%=MOD; &#125; for(auto t : same)&#123; res*=SAME[t]; res%=MOD; &#125; for(auto t : unsame)&#123; res*=DIFF[t]; res%=MOD; &#125; //cout&lt;&lt;res&lt;&lt;endl; return res;&#125;long long DPSAME(int x)&#123; if(SAME[x]!=-1) return SAME[x]; long long res=0; if(x%2)&#123; res+=(DPSAME(x/2)*DPSAME(x/2))%MOD; res%=MOD; res+=((((m-1)*DPDIFF(x/2))%MOD)*DPDIFF(x/2))%MOD; res%=MOD; &#125; else &#123; res=((m-1)*DPDIFF(x-1))%MOD; &#125; return SAME[x]=res;&#125;long long DPDIFF(int x)&#123; if(DIFF[x]!=-1) return DIFF[x]; long long res=0; if(x%2)&#123; res+=((((m-2)*DPDIFF(x/2))%MOD)*DPDIFF(x/2))%MOD; res%=MOD; res+=(2LL*((DPSAME(x/2)*DPDIFF(x/2))%MOD))%MOD; res%=MOD; &#125; else &#123; res+=((m-2)*DPDIFF(x-1))%MOD; res%=MOD; res+=DPSAME(x-1); res%=MOD; &#125; return DIFF[x]=res;&#125;void init(int n)&#123; memset(DIFF,-1,sizeof(DIFF)); memset(SAME,-1,sizeof(SAME)); SAME[0]=0; DIFF[0]=1; for(int i=0;i&lt;200005;i++)&#123; if(SAME[i]==-1)&#123; DPSAME(i); &#125; &#125; for(int i=0;i&lt;200005;i++)&#123; if(DIFF[i]==-1)&#123; DPDIFF(i); &#125; &#125;&#125;int main(void)&#123; int i,j,n,a,pre; scanf("%d %lld",&amp;n,&amp;m); init(n); pre=-1; for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a); if(i&amp;1)&#123; even.push_back(a); &#125; else &#123; odd.push_back(a); &#125; &#125; printf("%lld\n",(ANS(even)*ANS(odd))%MOD);&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Nice-Problem</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash的一些应用]]></title>
    <url>%2FHashsubstring%2F</url>
    <content type="text"><![CDATA[Hash的一些应用在前面我们了解到了进制hash和多重hash。但是这些并不能让我们能够解题，因为这些实在是太浅了。我们本文讨论如何解决一些实际问题。 本文定义一种更简单的hash方式-单hash hash[i]=(hash[i-1]*p+s[i])\%mod其中$p$是质数，$mod$是取模数，对于此种Hash方法，将$p$和$mod$尽量取大即可，这种情况下，冲突的概率是很低的。 当然也可以使用双hash使用二元组来表示结果 \begin{equation} \begin{split} hash1[i]=(hash1[i-1]*p+s[i])\%mod1 \\ hash2[i]=(hash2[i-1]*p+s[i])\%mod2 \end{split} \end{equation}我们仅仅使用两个不同的$mod$即可，最后结果使用一个二元组表示答案: (hash1[n],hash2[n])这种方式冲突的概率几乎是0。 我们如何获取子串的hash值如果我们存储了一个字符串的各个位置的hash值，那么我们可以$O(1)​$的获取到子串的hash值。 我们可以举一个简单的例子： \begin{eqnarray} && hash[1]=s_1 \\ && hash[2]=s_1*p+s_2 \\ && hash[3]=s_1*p^2+s_2*p+s_3 \\ && hash[4]=s_1*p^3+s_2*p^2+s_3*p+s_4 \end{eqnarray}假如我们需要$s_3s_4$的hash值的话，我们其实可以通过$hash[4]$和$hash[2]​$的值计算得到结果，我们其实可以很简单的发现值其实就是: hash[4]-hash[2]*p^{4-3+1}我们可以通过一个预处理把$p^x$都存储起来，需要的时候直接访问就行了。 其实就是相当于求$l-r​$区间的值，结果就是: hash[r]-hash[l-1]*p^{r-l+1}由于我们之前每次对hash值取mod,且中间是减号。 那么我们的结果应该是： ((hash[r]-hash[l-1]*p^{r-l+1})\%mod+mod)\%mod一些经典问题题型一给两个串$s_1,s_2$，问$s_2$是否在$s_1$中出现，且出现了几次。 解法我们可以$O(n)$的构造所有的长度等于$s_2$的子串的Unordered_map值放入map中进行统计。最后根据$s_2$的hash值输出答案即可。 题型二给定n个字符串，之后给一个大文章$S​$，问哪些字符串在其中出现了。 文章串长度$|s|&lt;1e5​$，n个单词串总长不超过$1e6​$且$n&lt;1e4​$。 解法我们可以$O(|S|n)$的构造合法子串的hash值放入Unordered_map中进行统计。最后根据$n$个字符串的hash值输出答案即可。 题型三给定两个字符串$s_1,s_2$，问两个串的最长公共子串是有多长。串长$s_1,s_2&lt;1e6$ 解法我们使用二分套hash+set的方法即可，时间复杂度是$O((n+m)\log(min(n,m)))$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull prime=12582917,prime2=402653189,prime3=1610612741;ull mod=50331653ll,mod2=402653189;//选择的时候注意prime*mod不要爆了ull,且prime&lt;modstring s,ss;set&lt;ull&gt; se;vector&lt;ull&gt; vec;int check(int m)&#123; //cout&lt;&lt;m&lt;&lt;endl; ull po=1,ans,i; for(i=0;i&lt;m;i++)&#123; po*=prime3; po%=mod; &#125; vec.clear(); se.clear(); ans=0; for(i=0;s[i];i++)&#123; ans=(ans*prime3%mod+(ull)s[i])%mod; vec.push_back(ans); &#125; se.insert(vec[m-1]); for(i=m;s[i];i++)&#123; se.insert(((vec[i]-(vec[i-m]*po)%mod)%mod+mod)%mod); &#125; vec.clear(); ans=0; for(i=0;ss[i];i++)&#123; ans=(ans*prime3+(ull)ss[i])%mod; vec.push_back(ans); &#125; if(se.count(vec[m-1])) return 1; for(i=m;ss[i];i++)&#123; if(se.count(((vec[i]-(vec[i-m]*po)%mod)%mod+mod)%mod)) return 1; &#125; return 0;&#125;int main(void) &#123; int i,j,n,m,l,r; cin&gt;&gt;s&gt;&gt;ss; l=1; r=min(s.size(),ss.size())+1; while(l&lt;r)&#123; m=(l+r)/2; if(check(m))&#123; l=m+1; &#125; else &#123; r=m; &#125; &#125; printf("%d\n",l-1);&#125; 题型四给一个字符串$S$，求$S​$的最长回文子串。 解法我们首先需要对$S$进行正向和反向的hash值，之后对每个位置进行二分长度即可。时间复杂度是$O(n\log n)$ 分享一个模板123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull prime=402653189;ull mod=1610612741;vector&lt;ull&gt; vec[10005];string s[10005];char ss[1505];ull HASH(string s,int x)&#123; ull ans=0; vec[x].clear(); for(int i=0;s[i];i++)&#123; ans=(ans*prime2+(ull)s[i])%mod; vec[x].push_back(ans); &#125; return ans;&#125;set&lt;ull&gt; se;int main(void)&#123; ull a,b,c,l,r; int n,i; scanf("%d",&amp;n); se.clear(); for(i=0;i&lt;n;i++)&#123; scanf("%s",ss); s[i]=ss; se.insert(HASH(s[i],i)); &#125; printf("%d\n",se.size());&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>HASH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法解析及其改进]]></title>
    <url>%2FKMP%2F</url>
    <content type="text"><![CDATA[KMP字符串匹配算法学过计算机的人应该都会知道knuth这个人吧？这个人太传奇了，直到今天，他还活着！！在他那个年代，他一生发明过许多算法。而KMP算法几乎是由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现的，于是后人为了念起来顺口纪念这三个人，取三个人的名字的首字母按字典序排序对该算法进行命名。 字符串匹配为了了解KMP算法，我们首先需要知道什么是字符串匹配，简单来说，给你两个字符串$A,B$，问你$A$中是不是有一个子串和$B$恰好一样。 首先对于这个问题，我们可以很简单的得到一个暴力算法。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main(void) &#123; string A,B; int i; while(cin&gt;&gt;A&gt;&gt;B)&#123; for(i=0;i+B.size()&lt;A.size();i++)&#123; if(A.substr(i,B.size())==B)&#123; printf("YES\n"); break; &#125; &#125; if(i+B.size()==A.size())printf("NO\n"); &#125;&#125; 很明显这个算法的复杂度是$O((n-m)*m)$级别的，其中$n,m$分别为字符串$A,B$的长度。 但是我们怎么如何改进算法呢？ 上述算法的问题所在首先我们举一个特殊的例子，看看算法到底在哪里冗余了。 我们可以看到，每次我们都向后匹配一位，直到最后停下来。不过这中间真的没有问题吗？其实我们可以很简单的就能发现下面的问题。 对于第一次匹配： 我们发现aba都是匹配的，但是接下来b和c并不能进行匹配。这个时候我们向后移动一位。 对于第二次匹配： a和b不匹配，我们向后移动一位。 我们可不可以避免这种情况的发生呢？因为我们通过第一次匹配已经知道了$A$中接下来连续的是ba这个串开头的，我们仅仅移动移动一步的话。还是会导致失配(就是当前的两个字符不匹配了)。我们可不可以跳过b，直接移动两位呢？显然我们人是可以很轻松的做到这一点的，等于说上述算法还有改进的空间！ 对于失配的情况我们应该如何移动？我们知道了aba匹配，但是下一步的字母我们不匹配，通过上面的分析可以知道我们应该直接跳过b，开始对a的匹配。 对于作为高智商的我们，现在有几个问题，请思考下面的问题： 对于ac匹配的情况，我们应该跳过几步呢？ 对于ababa匹配的情况，我们应该跳过几步呢？同时现在是什么字符和$A$进行匹配呢？ 对于ababc匹配的情况，我们应该跳过几步呢？同时现在是什么字符和$A$进行匹配呢？ 对于abcabc匹配的情况，我们应该跳过几步呢？同时现在是什么字符和$A$进行匹配呢？ 请思考之后，把答案记在心里，再继续往下看，想必会有更加深刻的理解！ 答案 对于ac匹配的情况下，我们需要直接跳过c。使用a和$A$串进行匹配。 对于ababa匹配的情况下，我们应该跳过b，同时使用第二个b与$A$串进行匹配 对于ababc匹配的情况下，我们应该跳过babc，同时使用第一个a与$A$串进行匹配 对于abcabc匹配的情况下，我们应该跳过bc，同时使用第二个a与$A$串进行匹配 上面的是不是很神奇？是不是感受到了我们原来还可以这样玩？有些东西只有思考之后才能感受到它们的乐趣！ 跳过的规律是什么呢？通过上面的分析，我们可以知道我们在发现失配的时候，我们可以更加智能的跳过一些字符，同时从$B$中间的某个位置开始匹配。但是这个是什么规律呢？我们应该遵从什么原则来确定跳动的位置呢？ 对于我们应该跳到哪里去，这里我直接给出答案，就是最长前缀后缀匹配的长度。 首先回到上面的几种情况。 对于ac来说：没有前缀和后缀能匹配上，所以长度是0，同时0也是a的下标。 对于ababa来说：我们能得到的最长前缀是abab，最长后缀是baba，但是两者不匹配。但是aba和aba是匹配的，所以我们可以跳到3这个位置，这个位置也就是第二个b的下标。 对于ababc来说：我们找不到任何一个前缀和后缀能匹配。所以我们跳到0，也就是第一个a的下标。 对于abcabc来说：由于最长的匹配是abc和abc，所以我们可以跳到长度为3的这个位置，这个位置也就是第二个a的下标。 NEXT数组通过上面的分析，我们是不是可以更加清楚的对上面的跳动有个了解了？那么我们这个时候需要用一个数组来记录每个位置失配之后，指导我们应该如何进行跳动，这个数组就叫做next数组。这个数组就是KMP算法的最重要的发现。我后面会直接给出实现代码，很简单。 不过我还是要做一些说明，因为NEXT数组为了方便使用，我们其实是错位了一次，即NEXT数组是向右移位了一次。 上面表示原字符串，下面表示的是当位置$i$发生了失配，那么我们应该跳去哪个位置进行比较，由于第一个位置发生失配的时候，我们可以直接往后走，所以使用-1进行标记。 匹配代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int nxt[10005];void get_nxt(string x) &#123; int i,j; nxt[0]=-1;nxt[1]=0; j=0; for(i=1;x[i];i++)&#123; while(j&amp;&amp;(x[j]!=x[i]))&#123; j=nxt[j]; &#125; if(x[j]==x[i]) j++; nxt[i+1]=j; &#125;&#125;int KMP(string A,string B) &#123; get_nxt(B); int i,j,cnt; j=0; cnt=0; for(i=0; A[i]; i++) &#123; while(j&amp;&amp;(A[i]!=B[j]))&#123; j=nxt[j]; &#125; if(A[i]==B[j]) j++; if(j==B.size()) return 1; &#125; return 0;&#125;char s[1000005];string A,B;int main(void) &#123; int i,j,T,n,m,x; scanf("%d",&amp;T); while(T--) &#123; scanf("%s",s); B=s;//被查找的串，也称模板串 scanf("%s",s); A=s;//主串 if(KMP(A,B)) printf("YES\n"); else printf("NO\n"); &#125;&#125; 强烈建议读者看完后自己手写一次，相信会有很大收获！给出一道例题HDU1686，修改上面的代码就能AC啦！ 我们还能更快吗？其实经过我们的思考之后，我们可以发现KMP并没有做到最好，因为就算我们使用NEXT数组进行跳动的话，但是指向的字符和之前的仍然是一个的话，还是会造成失配，特殊情况就是全部都是相同字母，我们会一个个依次跳动，慢慢回到原点，而实际上，我们应该直接跳回起点重新匹配。故我们可以再做一个修改。得到更好的NEXT数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int nxt[10005];void get_nxt(string x) &#123; int i,j; nxt[0]=-1; nxt[1]=0; j=0; for(i=1; x[i]; i++) &#123; while(j&amp;&amp;(x[j]!=x[i])) &#123; j=nxt[j]; &#125; if(x[j]==x[i]) j++; nxt[i+1]=j; &#125; for(i=1; x[i]; i++) &#123; j=nxt[i]; while(j&amp;&amp;(x[j]==x[i])) &#123; j=nxt[j]; &#125; nxt[i]=j; &#125;&#125;int KMP(string A,string B) &#123; get_nxt(B); int i,j,cnt; j=0; cnt=0; for(i=0; A[i]; i++) &#123; while(j&amp;&amp;(A[i]!=B[j])) &#123; j=nxt[j]; &#125; if(A[i]==B[j]) j++; if(j==B.size()) cnt++; &#125; return cnt;&#125;string A,B;int main(void) &#123; char s[1000005]; int i,j,T,n,m,x; scanf("%d",&amp;T); while(T--) &#123; scanf("%s",s); B=s; scanf("%s",s); A=s; cout&lt;&lt;KMP(A,B)&lt;&lt;endl; &#125;&#125; 我们还能更快更快更快吗？通过上面的想法，我们想到了指向的字符和之前的仍然是一个的话，还是会造成失配。我们避免这种情况的方法也非常原始，找第一个匹配和上一个位置不同的位置。我们这样确实在一定程度上改进了算法，但是我们还可以做的更好，但是这个就属于空间换时间的做法了，即我们在构建next数组的时候，假定当前失配了，且我当前的字符是$x$的话，我们应该跳去哪里。于是，我们可以再次改进kmp算法。不过这个常数比较大，对于单次的kmp算法来说，这种时间复杂度是得不偿失的。不过对于这样的场景来说还是很有必要的：CF1163D 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int K = 1005, N = 55, M = 55, INF = 1E9 + 7;int k, n, m;int kmp_s[N], nxt_s[N][26], kmp_t[M], nxt_t[M][26];int dp[K][N][M];char code[K], s[N], t[M];void init(char s[], int n, int kmp[], int nxt[][26])&#123; kmp[1] = 0; for (int i = 2; i &lt;= n; i++) &#123; int cur = kmp[i - 1]; while (cur &gt; 0 &amp;&amp; s[cur + 1] != s[i]) cur = kmp[cur]; if (s[cur + 1] == s[i]) ++cur; kmp[i] = cur; &#125; for (int i = 0; i &lt;= n; i++) for (char c = 'a'; c &lt;= 'z'; c++) &#123; int cur = i; while (cur &gt; 0 &amp;&amp; s[cur + 1] != c) cur = kmp[cur]; if (s[cur + 1] == c) ++cur; nxt[i][c - 'a'] = cur; &#125;&#125;int main()&#123; scanf("%s%s%s", code + 1, s + 1, t + 1); k = strlen(code + 1); n = strlen(s + 1); m = strlen(t + 1); init(s, n, kmp_s, nxt_s); init(t, m, kmp_t, nxt_t); for (int i = 0; i &lt;= k; i++) for (int ks = 0; ks &lt;= n; ks++) for (int kt = 0; kt &lt;= m; kt++) dp[i][ks][kt] = -INF; dp[0][0][0] = 0; for (int i = 0; i &lt; k; i++) for (int ks = 0; ks &lt;= n; ks++) for (int kt = 0; kt &lt;= m; kt++) for (char c = 'a'; c &lt;= 'z'; c++) if (code[i + 1] == '*' || code[i + 1] == c) // we now add/replace the (i + 1)-th character &#123; int ns = nxt_s[ks][c - 'a'], nt = nxt_t[kt][c - 'a']; int tmp = dp[i][ks][kt] + (ns == n) - (nt == m); // add the new occurrences if any dp[i + 1][ns][nt] = max(dp[i + 1][ns][nt], tmp); &#125; int ma = -INF; for (int ks = 0; ks &lt;= n; ks++) for (int kt = 0; kt &lt;= m; kt++) ma = max(ma, dp[k][ks][kt]); printf("%d\n", ma);&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑距离问题]]></title>
    <url>%2FEditdistance%2F</url>
    <content type="text"><![CDATA[编辑距离问题我们在使用word、Pycharm等软件的时候会相对比较智能对我们所写的单词进行自动补全，同时在我们犯错之后给我们相应的修改建议，但是推荐的单词的标准是什么呢？由此而来就提出了一个非常有意思的问题，给出一个单词A，找到与A最接近的单词。此时的衡量标准就是各种编辑距离。 Levenshtein distance定义Levenshtein distance也称作L氏距离，它能够按操作次数衡量两个字符串$A,B$之间的相似度，对于L氏距离，它支持3种操作： 在$A$中增加一个字母 在$A$中减少一个字母 在$A$中将一个字母进行替换 一个例子：input$A$=ca $B$=abc output3 ca -&gt; a-&gt; ab -&gt; abc 解法对于这个问题，我们直接进行分析不太好下手，暴力都不好实现，此时我们考虑动态规划算法。 我们定义状态$DP[i][j]$表示$A$串走到第$i$位，$B$串走到第$j$位，此时使它们相同的时候最少的操作次数。 对于第1种操作：在A中增加一个字符，此时对应的状态转移函数为： DP[i][j]=DP[i][j-1]+1如何理解：我们在$A$的第$i$位后增加一个字符，相当于我们增加的字符等于$B[j]$，此时我们只需要考虑$A$串前$i$位和$B$串前$j-1$位的距离即可。 对于第2种操作：在A中减少一个字符，此时对应的状态转移函数为： DP[i][j]=DP[i-1][j]+1如何理解：我们将第$i​$位删去，那么我们很轻松的可以想到转移方程。 对于第3种操作：在A中修改一个字符，此时对应的状态转移函数为： DP[i][j]=DP[i-1][j-1]+(A[i]!=B[j])如何理解：我们将第$i$位修改，这时候如果$A[i]==B[j]$时，那么我们无需修改，已经是最优了。但是不同时我们需要将操作次数加1，使得$A[i]=B[j]$ 代码123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int dp[1005][1005];int main(void)&#123; int i,j,n,m,cnt,pre,ans; string A,B; while(cin&gt;&gt;A&gt;&gt;B)&#123; for(i=0;i&lt;1005;i++) dp[i][0]=dp[0][i]=i;//增加边界的情况，想一想为什么。 A="A"+A;B="A"+B;// 增加边界 for(i=1;A[i];i++)&#123; for(j=1;B[j];j++)&#123; dp[i][j]=min(dp[i-1][j],dp[i][j-1])+1; dp[i][j]=min(dp[i][j],dp[i-1][j-1]+(A[i]!=B[j])); &#125; &#125; cout&lt;&lt;dp[A.size()-1][B.size()-1]&lt;&lt;endl; &#125;&#125; Damerau distance定义Damerau距离也被称作为D氏距离，他认为L式距离有一个不人性化的地方，我们在使用电脑写单词的时候很容易出现我们打字的失误，就是两个字母不小心敲反了，比如ea不小心敲成了ae，这个时候L氏距离给出的答案是2，这是十分不合理的。所以D氏距离新包含一种操作就是交换两个相邻字母。对于D氏距离支持4种操作。 在$A​$中增加一个字符 在$A$中删去一个字符 在$A$中修改一个字符 在$A$中交换两个字符 实际问题D氏距离有一个缺点，它打乱了原有单词的结构。对于abc-&gt;ca，我们的答案是3还是2？ 对于2的情况下：abc-&gt;ac-&gt;ca 对于3的情况下：abc-&gt;acb-&gt;cab-&gt;ca 按照实际的D式距离，它的结果是2。 不过D式距离的定义是没有问题的，它满足距离的三要素： 距离大于0 满足对称性 dis(a,b)+dis(b,c)&gt;=dis(a,c) 不过实际中D式距离的效果并不如L式距离。 Damerau Levenshtein distance定义Damerau Levenshtein 距离也称作为DL距离。它其实并不满足距离定义的三要素，它的存在只是为了满足L氏距离不包含交换操作的遗憾，不过这个算法修改了交换的定义，也就使得abc-&gt;ca的结果被错误的计算成3了，但是实际工程中并不影响的应用，相反的可以带来很多便利，于是这个错误也被一直沿用了下来。 在$A$中增加一个字符 在$A$中删去一个字符 在$A$中修改一个字符 在$A$中交换两个字符，同时不允许在其基础上再操作 算法12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int dp[1005][1005];int main(void)&#123; int i,j,n,m,cnt,pre,ans; string A,B; while(cin&gt;&gt;A&gt;&gt;B)&#123; for(i=0;i&lt;1005;i++) dp[i][0]=dp[0][i]=i;//增加边界的情况，想一想为什么。 A="A"+A;B="A"+B;// 增加边界 for(i=1;A[i];i++)&#123; for(j=1;B[j];j++)&#123; if(A[i]==B[j]) dp[i][j]=dp[i-1][j-1]; else if(A[i-1]==B[j]&amp;&amp;A[i]==B[j-1])&#123; dp[i][j]=min(min(dp[i-1][j-1],dp[i][j-1]),dp[i-1][j]); if(i&gt;=2&amp;&amp;j&gt;=2)&#123; dp[i][j]=min(dp[i][j],dp[i-2][j-2]); &#125; dp[i][j]+=1; &#125; else &#123; dp[i][j]=min(min(dp[i-1][j-1],dp[i][j-1]),dp[i-1][j]); dp[i][j]+=1; &#125; &#125; &#125; cout&lt;&lt;dp[A.size()-1][B.size()-1]&lt;&lt;endl; &#125;&#125; 国际惯例有关编辑距离计算的一点整理]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Nice-Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串清除问题]]></title>
    <url>%2FStringClear%2F</url>
    <content type="text"><![CDATA[字符串清除问题最近做比赛的时候，遇到了几道相似的字符串清除题目。 CF438D-Flood Fill题目大意给我们一个有$n$个数的数组，我们可以选择一个位置作为起始点，每次操作我们可以将包含起始点的特殊区间中的每个数替换为别的数，所谓特殊区间意思就是区间内原本的数要求全部相同。问我们最少进行几次操作可以使得所有的数都一样。 数据范围：n&lt;5000 样例：input:45 2 2 1 output:2 解法:首先很容易想到我们可以合并相同的颜色，这可以简化问题。 看到数据范围，我们很容易想到区间DP的解法。我们知道进行区间DP的时候，只需要考虑$[l,r]$与子区间的关系即可。同时为了进行区间DP，我们最少应该知道$[l,r]$区间与$[l+1,r]$,$[l,r-1]$,$[l+1,r-1]$三个区间的关系。但是我们应该怎么定义转移状态呢？我们考虑从两边向中间逼近，因为这时候的转移必定包含起始点。 对于区间$[l+1,r-1]​$，显然，我们可以知道$[l,r]​$相比$[l+1,r-1]​$最多要多两次操作。但是在$l​$和$r​$颜色相同的时候，我们只需要进行一次操作就可以了。 对于区间$[l+1,r]$，我们可以知道$[l,r]$相比$[l+1,r]$最多要多一次操作。因为相邻的颜色不相同。而$[l+1,r]$区间最后的颜色肯定是和$l+1$或者$r$的颜色相同。 对于区间$[l,r-1]$，我们可以知道$[l,r]$相比$[l,r-1]$最多要多一次操作。因为相邻的颜色不相同。而$[l,r-1]$区间最后的颜色肯定是和$l$或者$r-1$的颜色相同。 思考完这些之后我们可以很轻松的写出代码。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[5005],dp[5005][5005];string s;int DP(int l,int r)&#123; if(l&gt;=r) return 0; if(dp[l][r]&gt;-1) return dp[l][r]; int res; res=DP(l+1,r-1)+1; if(a[l]!=a[r]) res++; res=min(res,DP(l+1,r)+1); res=min(res,DP(l,r-1)+1); return dp[l][r]=res;&#125;int main(void)&#123; scanf("%d",&amp;n); int i; memset(dp,-1,sizeof(dp)); for(i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); if(i) &#123; if(a[i]==a[i-1])&#123; n--; i--; &#125; &#125; &#125; cout&lt;&lt;DP(0,n-1)&lt;&lt;endl;&#125; EduCF61F-Clear the String题目大意给我们一个有$n$个数的数组，我们可以进行一系列操作，每次操作我们可以将任意的特殊区间中的每个数替换为别的数，所谓特殊区间意思就是区间内原本的数要求全部相同。问我们最少进行几次操作可以使得所有的数都一样。 数据范围：n&lt;500 样例input:5abaca output:3 解法乍一看，题目好像没什么区别，上一题在转移的时候需要包含起始点，但是这次不需要包含起始点。根据前面的思想，我们可以想到对于$[l+1,r]$和$[l,r-1 ]$ 的时候，转移还是一样的。但是现在要求的特殊区间不需要包含起始点，等于说我们需要对任意一个子区间得到转移，也就是说$[l,r]$和$[l,k][k+1,r]$的关系要知道。这正是区间DP所擅长的。 于是我们可以写出代码： 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[505],dp[505][505];string s;int DP(int l,int r)&#123; if(l&gt;r) return 0; if(l==r) return 1; if(dp[l][r]&gt;-1) return dp[l][r]; int res,i; res=DP(l+1,r); if(a[l]!=a[r]) res++; for(i=l+1;i&lt;=r;i++)&#123; if(a[l]==a[i])&#123; res=min(res,DP(l,i-1)+DP(i+1,r)); &#125; &#125; return dp[l][r]=res;&#125;int main(void)&#123; scanf("%d",&amp;n); int i; cin&gt;&gt;s; a[0]=s[0]; n=1; memset(dp,-1,sizeof(dp)); for(i=1;s[i];i++)&#123; if(s[i]==s[i-1]) continue ; a[n++]=s[i]; &#125; cout&lt;&lt;DP(0,n-1)&lt;&lt;endl;&#125; EduCF59E-Vasya and Binary String题目大意给我们包含$n&lt;100$个数的01字符串$s$（其实可以扩展成abcd这样的？），同时给我们奖励数组$a$。之后我们每次可以消去相同的连续的数，若消去了$x$个数，我们就可以得到$a[x]$分，问我们最多能得多少分？ 样例input711010013 4 9 100 1 2 3 output109 hint1101001 → 111001 → 11101 → 1111 → ∅ 解法这个题目就是明显的DP了，我们的构造方式也很简单，但是需要仔细思考。 定义$DP[start][end][sum]$表示从$start$到$end$这个区间中前缀出现了$sum$次的结果是什么。 对于每一个状态$DP(start,end,sum)$，我们只有两种选择： $start$向后走一步，此时的答案就是$DP(start+1,end,0)+a[sum+1]$ 或者我们构造更长的前缀，此时我们应该找一个和$s[start]$相同的位置$i$，之后将中间的全部消去，我们遍历每一个节点即可，此时的状态转移应该是$DP(start+1,i-1,0)+DP(i,end,sum+1)$。 代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;long long dp[105][105][105],a[105]=&#123;0&#125;;string s;long long DP(int l,int r,int sum)&#123; long long res,i; if(l&gt;r) return 0; if(l==r) return max(a[1]+a[sum],a[sum+1]); if(dp[l][r][sum]!=-1) return dp[l][r][sum]; res=max(a[1]+DP(l+1,r,0)+a[sum],a[sum+1]+DP(l+1,r,0)); for(i=l+1;i&lt;=r;i++)&#123; if(s[i]==s[l])&#123; res=max(res,DP(l+1,i-1,0)+DP(i,r,sum+1)); &#125; &#125; return dp[l][r][sum]=res;&#125;int main(void)&#123; long long i,j,n,m; scanf("%lld",&amp;n); cin&gt;&gt;s; for(i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;a[i]); &#125; memset(dp,-1,sizeof(dp)); cout&lt;&lt;DP(0,n-1,0)&lt;&lt;endl;&#125; 2019.4.3微软笔试题有$n$个瓶子，每个瓶子有其自己的编号$a[i]$且$1&lt;a[i]&lt;1000​$，每次可以自己选择射击一个连续的序列，如果是回文串的话，可以一次全部击倒。最少几次可以全部击倒？ 样例input6 3 4 5 4 4 3 output2 解法这个题目也是明显的DP。首先我们可以想到每次消去的是任意区间，于是这道题目我们必须知道对于$[l,r]​$区间的任意两个子区间$[l,k],[k,r]​$的结果是如何合并的。 对于一个区间$[l,r]​$ 而言，我们有两种选择： $a[l]==a[r]$的情况下 那么我们在消去子区间$[l+1,r-1]$的最后一枪的时候，我们可以不花任何代价的顺带击倒，于是此时的转移应该包括这种特殊情况。 dp[l][r]=dp[l+1][r-1] 同时我们也需要暴力的枚举$k$，找最小值，因为不见得$a[l]$和$a[r]$两个合并在一起就是最优解，还有别的合并方式。 dp[l][r]=min(dp[l][k]+dp[k+1][r]) $a[l]!=a[r]​$的情况下 这个时候我们只能暴力的枚举$k​$，找最小值了 dp[l][r]=min(dp[l][k]+dp[k+1][r]) 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int dp[505][505],a[505],n;int DP(int l,int r) &#123; if(l&gt;=r) return 1; if(dp[l][r]!=-1) return dp[l][r]; int res,i; res=DP(l+1,r)+1; if(a[l]==a[r]) &#123; res=min(res,DP(l+1,r-1)); &#125; for(i=l+1; i&lt;r; i++) &#123; res=min(res,DP(l,i)+DP(i+1,r)); &#125; return dp[l][r]=res;&#125;int main(void) &#123; int i,j,m,T; scanf("%d",&amp;n); for(i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); &#125; memset(dp,-1,sizeof(dp)); cout&lt;&lt;DP(1,n)&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Numpy函数解析]]></title>
    <url>%2FNumpy%2F</url>
    <content type="text"><![CDATA[NumpyNumpy作为一个工具包，已经得到了大量的应用，可以说只要你用Pyhton，都必须要接触到这个工具包，但是numpy中的函数你真的了解吗？本文结合我自己的使用过程，对一些函数进行一些总结，这样我们在用时方便查找。 导入我们在使用时为了方便，通常在导入时将numpy重命名为np。 1import numpy as np 版本号1np.__version__ 我现在使用的版本是以下版本： 11.13.0 一般来说，numpy在版本更新后，函数用法都是不会改变的。所以这个也不需要纠结什么，直接往下走就行了。 创建numpy数组创建numpy数组的方式多种多样，不过以下几种基本够用： array()这个函数的参数为list或者array。传入list之后我们可以得到array类型的变量。传入array类型的话，我们会得到一个原array的拷贝。这里都可以是多维的list。 1234567891011&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; x=np.array(x)&gt;&gt;&gt; y=np.array(x)&gt;&gt;&gt; y[0]=4&gt;&gt;&gt; print(x,y)[1 2 3] [4 2 3]&gt;&gt;&gt; x=[[1,2,3],[4,5,6]]&gt;&gt;&gt; x=np.array(x)&gt;&gt;&gt; print(x)[[1 2 3] [4 5 6]] asarray()这个函数的函数是list或者array。传入list之后我们可以得到array类型的变量。不过传入array变量的话，我们只会得到一个原array的引用。这里都可以是多维的list。 12345678910111213&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; x=np.asarray(x)&gt;&gt;&gt; print(x)[1 2 3]&gt;&gt;&gt; y=np.asarray(x)&gt;&gt;&gt; y[0]=4&gt;&gt;&gt; print(x,y)[4 2 3] [4 2 3]&gt;&gt;&gt; x=[[1,2,3],[4,5,6]]&gt;&gt;&gt; x=np.asarray(x)&gt;&gt;&gt; print(x)[[1 2 3] [4 5 6]] 这个例子很好的反应了两者的区别。 zeros()这个函数传入的参数是shape，我们可以得到相应shape的全零矩阵。 123456789101112&gt;&gt;&gt; x=np.zeros([2,2],dtype=np.int32)&gt;&gt;&gt; print(x)[[0 0] [0 0]]&gt;&gt;&gt; x=np.zeros([2,2],dtype=np.float32)&gt;&gt;&gt; print(x)[[ 0. 0.] [ 0. 0.]]&gt;&gt;&gt; x=np.zeros([2,1],dtype=np.float64)&gt;&gt;&gt; print(x)[[ 0.] [ 0.]] ones()这个函数传入的参数是shape，可以得到相应shape全一矩阵。其中dtype是可选参数，其表示的是array里面的数据类型。默认的数据类型是np.float64。支持的参数有np.int32，np.int64 ，np.str，np.float32等。 123456789101112&gt;&gt;&gt; x=np.zeros([2,2],dtype=np.int32)&gt;&gt;&gt; print(x)[[ 1 1] [ 1 1]]&gt;&gt;&gt; x=np.zeros([2,2],dtype=np.float32)&gt;&gt;&gt; print(x)[[ 1. 1.] [ 1. 1.]]&gt;&gt;&gt; x=np.zeros([2,1],dtype=np.float64)&gt;&gt;&gt; print(x)[[ 1.] [ 1.]] full()这个函数功能相对比较简单，传入shape和填充值，之后得到填充后的array 123&gt;&gt;&gt; np.full([2,5],6)array([[6, 6, 6, 6, 6], [6, 6, 6, 6, 6]]) arange()这个函数有几种使用方式。 传入单个整数$x$，我们可以得到0到$x-1$的连续数组成的array。 123&gt;&gt;&gt; x=np.arange(5)&gt;&gt;&gt; print(x)[0 1 2 3 4] 传入两个数$L$与$R$，我们可以得到$L$到$R-1$的连续数组成的array。 123&gt;&gt;&gt; x=np.arange(1,6)&gt;&gt;&gt; print(x)[1 2 3 4 5] 传入三个数$L$,$R$,$step​$,我们根据步长得到相应的array。 123456&gt;&gt;&gt; x=np.arange(1,100,30)&gt;&gt;&gt; print(x)[ 1 31 61 91]&gt;&gt;&gt; x=np.arange(1,101,10)&gt;&gt;&gt; print(x)[ 1 11 21 31 41 51 61 71 81 91] eye()和identity()这两个函数的功能在我看来是一样的，都是得到单位阵。我们只需要传入相应的阶数就好了。 12345678&gt;&gt;&gt; np.eye(3)array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]])&gt;&gt;&gt; np.identity(3)array([[ 1., 0., 0.], [ 0., 1., 0.], [ 0., 0., 1.]]) zeros_like()、ones_like()、fulls_like()zeros_like()、ones_like()这两个函数依然是生成全零矩阵或者全一矩阵。其参数是一个array变量。之后会生成相同shape,dtype的全零\一矩阵。 12345678&gt;&gt;&gt; x=np.eye(3)&gt;&gt;&gt; np.zeros_like(x)array([[ 0., 0., 0.], [ 0., 0., 0.], [ 0., 0., 0.]])&gt;&gt;&gt; x = np.arange(4, dtype=np.int64)&gt;&gt;&gt; np.ones_like(x)array([1, 1, 1, 1], dtype=int64) 对于fulls_like()这个函数的话就是生成一个shape相同的填充矩阵。 123&gt;&gt;&gt; x = np.arange(4, dtype=np.int64)&gt;&gt;&gt; np.full_like(x,6,dtype=np.int64)array([6, 6, 6, 6], dtype=int64) copy()copy函数也很简单，参数就是一个array。我们在这里与上面的array函数和asarray函数做对比。 123456789101112&gt;&gt;&gt; x = np.array([1, 2, 3])&gt;&gt;&gt; print(id(x),x)1993915146032 [1 2 3]&gt;&gt;&gt; y = np.copy(x)&gt;&gt;&gt; print(id(y),y)1993915571216 [1 2 3]&gt;&gt;&gt; y=np.array(x)&gt;&gt;&gt; print(id(y),y)1993901738224 [1 2 3]&gt;&gt;&gt; y = np.asarray(x)&gt;&gt;&gt; print(id(y),y)1993915146032 [1 2 3] 我们可以看到copy后所占用的内存块与原内存块并不相同。也就是说array函数可以替代copy函数。但是asarray函数并不能替代copy函数。 linspace()这个函数可以完成$n$等份分割。参数是$L$,$R$,$n$ 123456&gt;&gt;&gt; np.linspace(3.,10,20)array([ 3. , 3.36842105, 3.73684211, 4.10526316, 4.47368421, 4.84210526, 5.21052632, 5.57894737, 5.94736842, 6.31578947, 6.68421053, 7.05263158, 7.42105263, 7.78947368, 8.15789474, 8.52631579, 8.89473684, 9.26315789, 9.63157895, 10. ]) logspace()老实说，我不知道什么时候用这个函数。。。。参数和上面的一样。 12345678&gt;&gt;&gt; np.logspace(3.,10, 20)array([ 1.00000000e+03, 2.33572147e+03, 5.45559478e+03, 1.27427499e+04, 2.97635144e+04, 6.95192796e+04, 1.62377674e+05, 3.79269019e+05, 8.85866790e+05, 2.06913808e+06, 4.83293024e+06, 1.12883789e+07, 2.63665090e+07, 6.15848211e+07, 1.43844989e+08, 3.35981829e+08, 7.84759970e+08, 1.83298071e+09, 4.28133240e+09, 1.00000000e+10]) diag()和diagflat()两个函数的作用都是生成一个方阵，参数是对角线的元素。 12345678910&gt;&gt;&gt; np.diag([1,2,3,4])array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]])&gt;&gt;&gt; np.diagflat([1,2,3,4])array([[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]) 行列操作reshape()reshape函数是把array重新分配行列的大小，参数首先是array对象，之后是shape。注意，我们传参数要保证合法，否则就会报错。 123456789&gt;&gt;&gt; x=[[1,2],[3,4]]&gt;&gt;&gt; x=np.array(x)&gt;&gt;&gt; np.reshape(x,[1,4])array([[1, 2, 3, 4]])&gt;&gt;&gt; np.reshape(x,[4,1])array([[1], [2], [3], [4]]) resize()这个方法和reshape()几乎一样。两个函数都是改变数组的形状，但是resize是在本身上进行操作，返回None，reshape返回的是修改之后的参数。 123456789101112131415161718192021222324252627&gt;&gt;&gt; x=np.arange(6).reshape(2,-1)&gt;&gt;&gt; y=np.reshape(x,(3,2))&gt;&gt;&gt; y,x(array([[0, 1], [2, 3], [4, 5]]), array([[0, 1, 2], [3, 4, 5]]))&gt;&gt;&gt; y=np.resize(x,(3,2))&gt;&gt;&gt; y,x(array([[0, 1], [2, 3], [4, 5]]), array([[0, 1, 2], [3, 4, 5]]))&gt;&gt;&gt; y=x.reshape(3,2)&gt;&gt;&gt; yarray([[0, 1], [2, 3], [4, 5]])&gt;&gt;&gt; xarray([[0, 1, 2], [3, 4, 5]])&gt;&gt;&gt; y=x.resize(3,2)&gt;&gt;&gt; y&gt;&gt;&gt; xarray([[0, 1], [2, 3], [4, 5]]) ravel()和flatten()这两个函数是将二维array按行或者按列拉长为一维array。 参数：{‘C’，‘F’，‘A’，‘K’} 默认情况下‘C’以行为主的顺序展开，‘F’（Fortran风格）意味着以列的顺序展开，‘A’表示如果$x​$在内存中为Fortran连续，则按列展开，否则以行展开，‘K’按照元素在内存中出现的顺序展平。 flatten不会影响原始矩阵，但是ravel是会修改数组。 123456789101112&gt;&gt;&gt; x=np.arange(1,7,1,dtype=np.int32).reshape(2,3)&gt;&gt;&gt; print(x)[[1 2 3] [4 5 6]]&gt;&gt;&gt; np.ravel(x)array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; np.ravel(x, order='F')array([1, 4, 2, 5, 3, 6])&gt;&gt;&gt; np.flatten(x)array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; np.flatten(x, order='F')array([1, 4, 2, 5, 3, 6]) swapaxes()这个函数可以改变交换维度的大小。 123456&gt;&gt;&gt; x=np.zeros([3,4,5])&gt;&gt;&gt; x.shape(3, 4, 5)&gt;&gt;&gt; x=np.swapaxes(x,0,1)&gt;&gt;&gt; x.shape(4, 3, 5) transpose()矩阵的转置，矩阵在二维的时候我们通常用.T来做同样的操作 123456789101112&gt;&gt;&gt; x=np.swapaxes(x,0,1)&gt;&gt;&gt; x.shape(4, 3, 5)&gt;&gt;&gt; x=np.zeros([3,4])&gt;&gt;&gt; x.shape(3, 4)&gt;&gt;&gt; x=x.transpose()&gt;&gt;&gt; x.shape(4, 3)&gt;&gt;&gt; y=x.T&gt;&gt;&gt; y.shape(3, 4) 当然在多维的时候，transpose可以做更多的事，我们可以指定需要转换成的维度。 1234&gt;&gt;&gt; x=np.zeros([3,4,5])&gt;&gt;&gt; x=np.transpose(x,[2,0,1])&gt;&gt;&gt; x.shape(5, 3, 4) expand_dims()这个函数的功能是添加维度，我们可以指定添加到第几个axis后。 1234567&gt;&gt;&gt; x=np.zeros([3,4])&gt;&gt;&gt; x=np.expand_dims(x,axis=1)&gt;&gt;&gt; x.shape(3, 1, 4)&gt;&gt;&gt; x=np.expand_dims(x,axis=0)&gt;&gt;&gt; x.shape(1, 3, 1, 4) squeeze()这个函数的功能很简单，把维度大小为1的维度，全部删除。 1234&gt;&gt;&gt; x=np.zeros([3,4,1])&gt;&gt;&gt; x=np.squeeze(x)&gt;&gt;&gt; x.shape(3, 4) concatenate()、hstack()、vstack()、dstack()concatenate这个函数在两个array进行拼接时用到，我们可以指定拼接到指定的axis上。有时候我们为了简化掉axis参数使用hstack()，这些函数。其中vstack()表示axis为0，其中hstack()表示axis为1，其中dstack()表示axis为3。 1234567891011121314&gt;&gt;&gt; x=np.arange(1,7,1)&gt;&gt;&gt; x=x.reshape(2,3)&gt;&gt;&gt; y=np.arange(7,13,1)&gt;&gt;&gt; y=y.reshape(2,3)&gt;&gt;&gt; out1=np.concatenate((x,y),axis=1)&gt;&gt;&gt; out2=np.hstack((x,y))&gt;&gt;&gt; assert np.allclose(out1,out2)&gt;&gt;&gt; print(x,"\n",y,"\n",out1)[[1 2 3] [4 5 6]] [[ 7 8 9] [10 11 12]] [[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] split()split函数可以对维度进行再切分。将维度扩充。 1234&gt;&gt;&gt; x=np.arange(1,10,1)&gt;&gt;&gt; x=np.split(x,[4,6])#在维度为第4和6的地方进行切分&gt;&gt;&gt; print(x)[array([1, 2, 3, 4]), array([5, 6]), array([7, 8, 9])] split函数还可以在指定的axis上进行切分。 123456789101112&gt;&gt;&gt; x=np.arange(16).reshape(2,2,4)&gt;&gt;&gt; x=np.split(x,[3],axis=2)#在第三维的第三个位置切分&gt;&gt;&gt; print(x)[array([[[ 0, 1, 2], [ 4, 5, 6]], [[ 8, 9, 10], [12, 13, 14]]]), array([[[ 3], [ 7]], [[11], [15]]])] tile()这个函数就是把array多重复几次。重复的次数用shape来表示。 1234&gt;&gt;&gt; x=np.arange(3)&gt;&gt;&gt; np.tile(x,[2,2])array([[0, 1, 2, 0, 1, 2], [0, 1, 2, 0, 1, 2]]) repeat()这个函数相比tile就是在重复的方式上不一样，是依次重复的。而且参数是整型数，而不是shape 123&gt;&gt;&gt; x=np.arange(3)&gt;&gt;&gt; np.repeat(x,2)array([0, 0, 1, 1, 2, 2]) trim_zeros()作用就是去掉array上头尾多余的0 1234&gt;&gt;&gt; x=np.array([0, 0, 0, 1, 2, 3, 0, 2, 1, 0])&gt;&gt;&gt; x=np.trim_zeros(x)&gt;&gt;&gt; print(x)[1 2 3 0 2 1] unique()这个函数就是返回一个排序的无重复元素的array。但是其有可选项return_counts，表示是否返回每个元素原先出现多少次。 1234&gt;&gt;&gt; x=np.array([2, 2, 1, 5, 4, 5, 1, 2, 3])&gt;&gt;&gt; uni,cnt=np.unique(x,return_counts=True)&gt;&gt;&gt; print(uni,cnt)[1 2 3 4 5] [2 3 1 1 2] fliplr()、flipud()两个函数表示把array里的左右顺序改变或者是上下顺序改变 1234567&gt;&gt;&gt; x=np.arange(1,9).reshape(2,4)&gt;&gt;&gt; np.fliplr(x)array([[4, 3, 2, 1], [8, 7, 6, 5]])&gt;&gt;&gt; np.flipud(x)array([[5, 6, 7, 8], [1, 2, 3, 4]]) rot90()表示将将array逆时针旋转90度。这个实际中有什么用？？？？ 1234&gt;&gt;&gt; x=np.arange(1,5).reshape(2,2)&gt;&gt;&gt; np.rot90(x)array([[2, 4], [1, 3]]) roll()可以在指定维度上循环array。 1234&gt;&gt;&gt; x=np.arange(1,9).reshape(2,4)&gt;&gt;&gt; np.roll(x,1,axis=1)array([[4, 1, 2, 3], [8, 5, 6, 7]]) 逻辑函数any()原array中有一个为1。则为真。 1234567&gt;&gt;&gt; x = np.array([1,0,0])&gt;&gt;&gt; print(np.any(x))True&gt;&gt;&gt;&gt;&gt;&gt; x = np.array([0,0,0])&gt;&gt;&gt; print(np.any(x))False all()原array必须全为1。才为真。 1234567&gt;&gt;&gt; x = np.array([1,2,3])&gt;&gt;&gt; print(np.all(x))True&gt;&gt;&gt;&gt;&gt;&gt; x = np.array([1,0,3])&gt;&gt;&gt; print(np.all(x))False allclose()、array_equal()allclose这个是用来比较两个array是否一样的，默认误差alot为1e-5。而array_equal则需要完全一样才可以。 1234&gt;&gt;&gt; print(np.allclose([3], [2.999999]))True&gt;&gt;&gt; print(np.array_equal([3], [2.999999]))False isclose()、equal()这两个函数是进行逐个位置进行比较。 123456&gt;&gt;&gt; print(np.array_equal([3], [2.999999]))False&gt;&gt;&gt; print(np.equal([1, 2], [1, 2.000001]))[ True False]&gt;&gt;&gt; print(np.isclose([1, 2], [1, 2.000001]))[ True True] 运算函数一一对应运算12345678910111213141516171819202122232425262728&gt;&gt;&gt; x=[[1,2,3],[4,5,6]]&gt;&gt;&gt; x=np.array(x)&gt;&gt;&gt; y=[[1,1,1],[2,2,2]]&gt;&gt;&gt; y=np.array(y)&gt;&gt;&gt; z=np.add(x, y)#一一对应的加上&gt;&gt;&gt; print(z)[[2 3 4] [6 7 8]]&gt;&gt;&gt; z=np.subtract(x, y)#一一对应的减去&gt;&gt;&gt; print(z)[[0 1 2] [2 3 4]]&gt;&gt;&gt; z=np.multiply(x, y)#一一对应的乘&gt;&gt;&gt; print(z)[[ 1 2 3] [ 8 10 12]]&gt;&gt;&gt; z=np.divide(x, y)#一一对应的除&gt;&gt;&gt; print(z)[[ 1. 2. 3. ] [ 2. 2.5 3. ]]&gt;&gt;&gt; z=np.power(x, y)#一一对应的次方，x^y&gt;&gt;&gt; print(z)[[ 1 2 3] [16 25 36]]&gt;&gt;&gt; z=np.mod(x, y)#一一对应的取模，x%y&gt;&gt;&gt; print(z)[[0 0 0] [0 1 0]] matmul()这个函数完成的功能是矩阵的乘法。 123456&gt;&gt;&gt; x=[2,3]&gt;&gt;&gt; y=[[1,0],[4,0]]&gt;&gt;&gt; x=np.array(x)&gt;&gt;&gt; y=np.array(y)&gt;&gt;&gt; np.matmul(x,y)array([14, 0]) inner()这个函数完成的功能是做内积。即矩阵的每一行依次乘上另一个矩阵的每一行。 123456&gt;&gt;&gt; x = [1,2]&gt;&gt;&gt; y = [[4, 1], [2, 2]]&gt;&gt;&gt; print(np.inner(x, y))[6 6]&gt;&gt;&gt; print(np.inner(y, x))[6 6] dot()这个函数有一些奇怪，我的理解是自适应的matmul()和inner()。优先检查两个矩阵是否可以做矩阵乘法，否则做内积。 123456&gt;&gt;&gt; x = [1,2]&gt;&gt;&gt; y = [[4, 1], [2, 2]]&gt;&gt;&gt; print(np.dot(x, y))[8 5]&gt;&gt;&gt; print(np.dot(y, x))[6 6] trace()这个函数用来运算矩阵的迹 123&gt;&gt;&gt; x=np.diag([1,2,3,-4])&gt;&gt;&gt; print(np.trace(x))2 矩阵分解、行列式等函数乔莱斯基(Cholesky)分解乔莱斯基分解： x=L*L.T123456&gt;&gt;&gt; x = np.array([[4, 12, -16], [12, 37, -43], [-16, -43, 98]], dtype=np.int32)&gt;&gt;&gt; L = np.linalg.cholesky(x)&gt;&gt;&gt; print(L)[[ 2. 0. 0.] [ 6. 1. 0.] [-8. 5. 3.]] QR分解QR分解：Q是正交矩阵(满秩，且都是标准正交基(长度为1))，R是上三角矩阵。常用的分解方法有house-holder、施密特正交化、Givens方法。 x=Q*R12345678910&gt;&gt;&gt; x = np.array([[12, -51, 4], [6, 167, -68], [-4, 24, -41]], dtype=np.float32)&gt;&gt;&gt; q, r = np.linalg.qr(x)&gt;&gt;&gt; print(q)[[-0.85714287 0.39428571 0.33142856] [-0.42857143 -0.90285712 -0.03428571] [ 0.2857143 -0.17142858 0.94285715]]&gt;&gt;&gt; print(r)[[ -14. -21. 14.] [ 0. -175. 70.] [ 0. 0. -35.]] SVD分解12345678910111213141516&gt;&gt;&gt; x = np.array([[1, 0, 0, 0, 2], [0, 0, 3, 0, 0], [0, 0, 0, 0, 0], [0, 2, 0, 0, 0]], dtype=np.float32)&gt;&gt;&gt; U, s, V = np.linalg.svd(x, full_matrices=False)&gt;&gt;&gt; print("U=\n", U, "\ns=\n", s, "\nV=\n", V)U= [[ 0. 1. 0. 0.] [ 1. 0. 0. 0.] [ 0. 0. 0. -1.] [ 0. 0. 1. 0.]]s= [ 3. 2.23606801 2. 0. ]V= [[-0. 0. 1. -0. 0. ] [ 0.44721359 -0. -0. -0. 0.89442718] [-0. 1. 0. -0. 0. ] [ 0. 0. 0. 1. 0. ]]&gt;&gt;&gt; assert np.allclose(np.dot(U, np.dot(np.diag(s), V)), x) 矩阵的特征值和特征向量/本征值和本征向量12345678910111213&gt;&gt;&gt; x = np.diag((1, 2, 3))&gt;&gt;&gt; eigenvals = np.linalg.eig(x)[0]&gt;&gt;&gt; eigenvals_ = np.linalg.eigvals(x)&gt;&gt;&gt; assert np.array_equal(eigenvals, eigenvals_)&gt;&gt;&gt; print("eigenvalues are\n", eigenvals)eigenvalues are [ 1. 2. 3.]&gt;&gt;&gt; eigenvecs = np.linalg.eig(x)[1]&gt;&gt;&gt; print("eigenvectors are\n", eigenvecs)eigenvectors are [[ 1. 0. 0.] [ 0. 1. 0.] [ 0. 0. 1.]] 逆1234&gt;&gt;&gt; x = np.array([[1., 2.], [3., 4.]])&gt;&gt;&gt; np.linalg.inv(x)array([[-2. , 1. ], [ 1.5, -0.5]]) 我的一些笔记123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224import numpy as np#生成函数x=[3,4,5]y=np.array(x)z=np.asarray(x)#注意此时array和asarray没有区别，都新申请了内存来存储x[1]=111print(x)print(y)print(z)x=np.zeros(3) #生成一个1*3维的全零矩阵y=np.array(x)z=np.asarray(x)#这时体现出array和asarray的区别，即x若为ndarray的话，asarray不在申请新内存了x[1]=999z[2]=888print(x)print(y)print(z)x=[2,3,4]y=np.array(x,dtype=np.float64)#转换为浮点数z=np.array(x,dtype=np.complex64)#转换为复数print(y)print(z)x=np.ones(3) #生成一个1*3的全1矩阵,默认为float64类型的print(x)print(type(x[1]))x=np.zeros(3, dtype=np.float32) #生成一个1*3的全0（float32类型）矩阵print(x)y=np.ones_like(x)#生成一个全为1的矩阵，矩阵的shape和传入的是一样的，数据类型也是一样的print(y)print(type(y[1]))x=np.eye(3)print(x)#生成一个3*3维的单位矩阵x=np.identity(3)#两个函数的功能一样print(x)#生成一个3*3维的单位矩阵x=np.arange(3)#生成一个0-2的矩阵print(x)x=np.arange(3,5)#生成一个3-4的矩阵print(x)x=np.arange(3,7,2)#生成一个3-6的步长为2的矩阵print(x)x=np.zeros(3)y=np.ones(3)z=np.where(0,x,y)print(z)z=np.where(1,x,y)print(z)x=[3,4,5,6,7,8]y=[3,3,6,6,7,8]x=np.array(x,dtype=np.float32)print(type(x[1]))print(np.in1d(x,y))#两个矩阵中的元素一一对应看看值是否相同，相同true，不同flase，且只与x的长度有关系x=[3,4,5]x=np.diag(x)#传进去的x表示的是对角线上的元素，生成的是一个方阵print(x)x=[[3,4,5],[5,6,7]] #这样就错了，只对一维的ndarray有效果的x=[3,4,5]x=np.array(x)x=np.diag(x)print(x)x=[2,3]y=[[1,0],[4,0]]x=np.array(x)y=np.array(y)#矩阵的乘法#(2.3)*(1,0) = (14,0)# (4,0)z=np.dot(x,y)print(z)x=np.diag([1,2,3,-4])print(np.trace(x)) #计算方阵的对角线元素的和x=[[4,3,2,1],[8,7,5,6]]x=np.array(x)print(x)x=np.sort(x)#对矩阵按维度进行排序print(x)x=[[4,4,3,2],[2,2,2,7]]x=np.array(x)x=np.unique(x)#不管多少维的矩阵，将其拉伸为一维，去重，排序，返回print(x)x=[[3,3,-3],[-4,-5,7]]x=np.array(x)x=np.abs(x)#不管多少维的矩阵，将其中每个元素取绝对值后返回int类型的x=np.fabs(x)#不管多少维的矩阵，将其中每个元素取绝对值后返回float类型的print(x)x=[[3,3,-3],[-4,-5,7]]x=np.array(x)print(np.mean(x))#不管多少维的，元素全部相加后，除以所有的个数，输出结果x=[[4,9,16],[4,25,100]]x=np.array(x)x=np.sqrt(x)#对每个元素开根号之后返回，注意元素不能为负数，否则结果会出错，而且这里自动将类型转换为了float了print(x)x=[[4,9,16],[4,25,100]]x=np.array(x)x=np.square(x)#对每个元素平方，不转换类型的##类似的还有np.exp(ndarray) 计算e^x 后返回##log、log10、log2、log1p ,计算ln,log10,log2,log(1+x)的log值print(x)x=[[3,3,-3],[-4,-5,7]]x=np.array(x)print(np.sign(x)) #查看矩阵中的每个元素的正负情况np.ceil(x)np.floor(x)np.rint(x)# 计算大于等于改值的最小整数# 计算小于等于该值的最大整数# 四舍五入到最近的整数，保留dtypex=[[1,2,3],[4,5,6]]x=np.array(x)y=[[1,1,1],[2,2,2]]y=np.array(y)z=np.add(x, y)#一一对应的加上print(z)z=np.subtract(x, y)#一一对应的减去print(z)z=np.multiply(x, y)#一一对应的乘上print(z)z=np.divide(x, y)#一一对应的除上print(z)z=np.power(x, y)#一一对应的次方print(z)z=np.mod(x, y)#一一对应的取模print(z)#np的常用的属性print(x.T)#矩阵的转置print(x.ndim)#获取ndarray的维度print(x.shape)#获取ndarray的各个维度的长度，若每一维的长度相同会返回(x,y)，若存在不同的会返回(x,)print(x.dtype)#值的类型print(x.T)#矩阵的转置x.T[2][1]=1#会修改的！！！print(x)#矩阵的转置y=xprint(x)y[1][1]=-1print(x)#这样的话会改变值的结果y=np.copy(x)#重新拷贝一个xy[0][0]=-100#这样的话不会改变结果了，这个还是很关键的呀print(x)print(y)x=[[1,2,3],[4,5,6]]x=np.array(x)print(x.T)#转置和reshape不一样的！！reshape是依次填格子。转置是XIJ=XJI！！！！！两个不一样的！x=x.reshape(3,2)print(x)x=[[1,2,3],[4,5,6]]x=np.array(x)y=[[1,1,1]]y=np.array(y)print(x.mean( axis=0 )) #按照列进行求平均值，返回的是一个一维的矩阵print(x.mean( axis=1 )) #按照行进行求平均值，返回的是一个一维的矩阵print(x.sum( axis=0 )) #按照列进行求和，返回的是一个一维的矩阵print(x.sum( axis=1 )) #按照行进行求和，返回的是一个一维的矩阵print(x.max( axis=0 )) #按照列返回最大的值，返回的是一个一维的矩阵print(x.max( axis=1 )) #按照行返回最大的值，返回的是一个一维的矩阵print(x.min( axis=0 )) #按照列返回最小的值，返回的是一个一维的矩阵print(x.min( axis=1 )) #按照行返回最小的值，返回的是一个一维的矩阵print(x.argmax( axis=0 )) #按照列返回最大的值的索引，返回的是一个一维的矩阵，在列的下标print(x.argmax( axis=1 )) #按照行返回最大的值的索引，返回的是一个一维的矩阵，在行的下标print(x.argmin( axis=0 )) #按照列返回最小的值的索引，返回的是一个一维的矩阵，在列的下标print(x.argmin( axis=1 )) #按照行返回最小的值的索引，返回的是一个一维的矩阵，在行的下标z=x.dot(y.T)#也是求矩阵的相乘print(z)#一维情况下x=np.arange(7)print(x)print(x[1]) #选取下标为1的元素print(x[1:3]) #选取下标为1的到下标为2的元素print(x[:]) #选取全部的元素print(x[1:]) #选取下标1开始的元素print(x[:5]) #选取下标0到下标4的元素#二维情况下x=[[1,2,3],[4,5,6]]x=np.array(x)print(x[1][1]) #选择第[1][1]个元素np.random.seed(4)#确定随机数种子x=np.random.permutation(6)#随机一个排列出来print(x)x=[1,2,4,4,5]x=np.random.permutation(x)#返回一个序列的随机排列print(x)x=np.random.randn(3,3)#生成一个3*3的正态分布（平均值为0,标准差为1）print(x)x=np.random.normal(size=(3,3))#生成一个3*3的正态（高斯）分布,注意这里有size参数的print(x)#NumPy.linalgx=np.diag([3,4,5])y=np.array([3,4,5])print(np.linalg.det(x)) #计算方阵的行列式的值print(np.linalg.eig(x)) #计算方阵的本征值和本征向量\特征值特征向量print(np.linalg.inv(x)) #计算矩阵的逆print(np.linalg.pinv(x)) #计算矩阵的伪逆print(np.linalg.qr(x)) #计算矩阵的qr分解print(np.linalg.svd(x)) #计算矩阵的奇异值分解print(np.linalg.solve(x,y.T)) #解线性方程组 print(np.linalg.lstsq(x,y.T)) #解线性方程组 最小二乘解]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数/质数]]></title>
    <url>%2FPrime%2F</url>
    <content type="text"><![CDATA[素数/质数素数/质数是一个非常容易被考察的点，其定义很简单：只有1和其本身能够将其整除。关于素数，衍生出了很多理论，这些理论对求解问题时能够极大的加速算法。本文我们探讨素数判定问题。 暴力判断这个就很简单了，由于除数肯定比被除数要小，所以我们对每个数进行枚举判断即可。时间复杂度$O(n)$ 1234567bool Is_prime(int n)&#123; for(int i=2;i&lt;n;i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 常用判断我们通常对上面的算法进行一些改进，假如说一个数不是素数。那么其肯定可以写成$a*b$的形式。我们规定$a$比$b$小。那么$a$最大为$\sqrt n$。之后我们再枚举所有的$a$，若能找到满足的$b$，那么就不是素数，对所有的$a$都不满组的话，就是素数。时间复杂度$O(\sqrt n)$ 12345678bool Is_prime(int n)&#123; int N=sqrt(n); for(int i=2;i&lt;=N;i++)&#123; if(n%i==0) return false; &#125; return true;&#125; 技巧判断我最近看到了一个有意思的idea，这也是写这篇文章的初心所在。我们将$n$记作为$6x+k$的形式。那么从5开始，所有的数可以被记作为：…$6x-1$,$6x$,$6x+1$,$6x+2$,$6x+3$,$6x+4$…的形式。 首先我们证明当$n$为素数的时候，$6x+k$中的$k​$只可能为-1和1。 当$k$为0的时候，$n​$可以被3整除。 当$k$为2的时候，$n$可以被2整除。 当$k$为3的时候，$n$可以被3整除。 当$k$为4的时候，$n$可以被2整除。 根据常识我们可以知道$6x+1$与$6x-1$是不可能被3整除(因为$6x$被3整除，其相邻的数必不可能被3整除)，同时为奇数。那么等于说$n$为素数的时候形式，只有可能是$6x+1$与$6x-1​$。其实这就是孪生素数，有兴趣的话，可以百深入了解一下。 于是我们可以很轻松的枚举出小于$\sqrt n$中的所有素数了，虽然会有大量的非素数被枚举到，但是还是能起到不错的效果，也许未来会出现更强的算法？ 123456789bool Is_prime(int n)&#123; if(n==1) return false; if(n==2||n==3) return true; if(n%6!=1&amp;&amp;n%6!=5) return false; for(register int i=5;i*i&lt;=n;i+=6) if(n%i==0||n%(i+2)==0) return false; return true;&#125; 素数测试我们使用费马小定理的逆定理来进行测试，若每次测试都满足的话，我们认为这个数就是素数。这个是个坑，以后以后机会补上。代码先搬一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;map&gt; #define ll long longusing namespace std;const int times = 20;int number = 0;map&lt;ll, int&gt;m;ll Random(ll n)//生成[ 0 , n ]的随机数&#123; return ((double)rand()/RAND_MAX*n+0.5);&#125;ll q_mul(ll a, ll b, ll mod)//快速计算 (a*b) % mod&#123; ll ans=0; while(b) &#123; if(b&amp;1) &#123; b--; ans=(ans+a)%mod; &#125; b/=2; a=(a+a)%mod; &#125; return ans;&#125;ll q_pow(ll a,ll b,ll mod)//快速计算 (a^b) % mod&#123; ll ans=1; while(b) &#123; if(b&amp;1) &#123; ans=q_mul(ans,a,mod ); &#125; b/=2; a=q_mul(a,a,mod); &#125; return ans;&#125;bool witness(ll a,ll n)//miller_rabin算法的精华&#123;//用检验算子a来检验n是不是素数 ll tem=n-1; int j=0; while(tem%2==0) &#123; tem/=2; j++; &#125; //将n-1拆分为a^r * s ll x=q_pow(a,tem,n); //得到a^r mod n if(x==1||x==n-1) return true;//余数为1则为素数 while(j--) //否则试验条件2看是否有满足的 j &#123; x=q_mul(x,x,n); if(x==n-1)return true; &#125; return false;&#125;bool miller_rabin(ll n)//检验n是否是素数&#123; if(n==2)return true; if(n&lt;2||n%2==0)return false;//如果是2则是素数，如果&lt;2或者是&gt;2的偶数则不是素数 for(register int i=1;i&lt;=times;i++)//做times次随机检验 &#123; ll a=Random(n-2)+1;//得到随机检验算子 a if(!witness(a,n))return false;//用a检验n是否是素数 &#125; return true;&#125;int main()&#123; ll x; while(cin&gt;&gt;x) &#123; if(miller_rabin(x)) cout&lt;&lt;"Yes"&lt;&lt;endl; else cout &lt;&lt;"No"&lt;&lt;endl; &#125; return 0;&#125; 埃拉托斯特尼筛法我们可以通过筛法的预处理使用$O(n\log\log n)$的时间得到小于$n​$的所有素数，思想很简单，素数的倍数不是素数。我们每次得到素数之后，将其的倍数全部舍弃就好了。 12345678910111213int p[100005],prime[100005],len;void init(int n)&#123; len=0; memset(prime,0,sizeof(prime)); for(int i=2;i&lt;=n;i++)&#123; if(prime[i]==0)&#123; p[len++]=i; for(j=i+i;j&lt;=n;j+=i)&#123; prime[j]=1; &#125; &#125; &#125;&#125; 动态图的话就是这样的： the Meissel, Lehmer, Lagarias, Miller, Odlyzko method这个是一个神奇的算法，我是照搬过来的，没有仔细研究过，只是当模板用过。。估计也研究不明白。这个算法可以快速的求1e18内有多少个素数小于某个数。算法的时间复杂度也是相当低，复杂度只有$O(\frac {n^\frac 3 4} {\log n})$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;#pragma warning(disable:4996)#define INF 2000000005#define lowbit(a) ((a)&amp;-(a))#define FAIL -INFconst long long MAXN=6893911;long long p[MAXN], cnt;bool mark[MAXN];int pi[MAXN];void init()&#123; long long i,j; for (i=2;i&lt;MAXN;i++) &#123; if (!mark[i]) p[cnt++]=i; pi[i]=pi[i-1]+!mark[i]; for (j=0;p[j]*i&lt;MAXN&amp;&amp;j&lt;cnt;j++) &#123; mark[p[j]*i]=true; if (i%p[j]==0) break; &#125; &#125;&#125;int f(long long n,int m)&#123; if (n==0)return 0; if (m==0)return n-n/2; return f(n,m-1)-f(n/p[m],m-1);&#125;int Pi(long long N);int p2(long long n, int m)&#123; int ans=0; for (int i=m+1;(long long)p[i]*p[i]&lt;=n;i++) ans+=Pi(n/p[i])-Pi(p[i])+1; return ans;&#125;int p3(long long n, int m)&#123; int ans=0; for (int i=m+1;(long long)p[i]*p[i]*p[i]&lt;=n;i++) ans+=p2(n/p[i],i-1); return ans;&#125;int Pi(long long N)&#123; if (N&lt;MAXN)return pi[N]; int lim=f(N,0.25)+1; int i; for (i=0;p[i]&lt;=lim;i++); int ans=i+f(N,i-1)-1-p2(N,i-1)-p3(N,i-1); return ans;&#125;int main()&#123; long long L,R; scanf("%lld %lld",&amp;L,&amp;R); init(); printf("%d",Pi(R)-Pi(L-1)); return 0;&#125; 参考文献洛谷日报-质数判定]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Prime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unordered_map & set]]></title>
    <url>%2FUnordered-mapset%2F</url>
    <content type="text"><![CDATA[Unordered_map &amp; setC++11发布后，出现了一些更加有用的容器，性能超过了STL中自带的容器，我们常用的有unordered_map,unordered_set,unordered_multiset。我们主要介绍一下unordered_multiset，通过我们前一篇文章的介绍，我们知道map和set是按照红黑树实现的，且内部按照键值排序的，即内部依然是有序的，这就导致了我们的查询是$O(\log n)$，但是我们很多时候都不需要这些多余的性质，于是出现了unordered这样的关键字，表示内部是无序的，这种数据结构本质借助了hash的思想。实现了$O(1)$ 的查询。map相当于java中的TreeMap，unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map；而空间复杂度方面，hash_map最低，unordered_map次之，map最大。 unordered_map与map的对比： 存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些。 总结：结构体用map重载&lt;运算符，结构体用unordered_map重载==运算符。 unordered_map与hash_map对比： unordered_map原来属于boost分支和std::tr1中，而hash_map属于非标准容器。 unordered_map感觉速度和hash_map差不多，但是支持string做key，也可以使用复杂的对象作为key。 unordered_map编译时gxx需要添加编译选项：—std=c++11 使用方式123456789101112131415161718192021#include&lt;unordered_set&gt;#include&lt;unordered_map&gt;#include&lt;bits/stdc++.h&gt;using namespace std;/*//不支持C++11的时候#include&lt;tr1/unordered_set&gt;#include&lt;tr1/unordered_map&gt;#include&lt;bits/stdc++.h&gt;using namespace std;using namespace tr1;*/unordered_set&lt;int&gt; s;unordered_multiset&lt;int&gt; ms;unordered_map&lt;int,int&gt; ii;int main(void)&#123; s.insert(6); ms.insert(7); ii[34]=178; cout&lt;&lt;ii[34]&lt;&lt;endl;&#125; 通过上面的代码，我们可以看到，和正常的使用方式一样，只不过效率更高了。但是由于内部是由hash实现的，所以肯定有投机取巧的素数可以卡掉unordered_map。$x=126271$就是一个神奇的素数，若将其和其的倍数插入到unordered_map当中，就会相当慢，甚至不如一般的map。 参考文献洛谷日报 neal’s blog]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>set</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL用法及其时间复杂度分析]]></title>
    <url>%2FSTL%2F</url>
    <content type="text"><![CDATA[STLSTL是C++语言中一个非常实用的代码库，叫做标准模板库，通常我们使用这个头文件即可导入STL。本文立足与C++，但是python其实也是大同小异。 setset正如其名，表示的是一个集合，其分为两类，set为数学上的集合，即不含重复元素，multiset为可重集合，即可以包含重复元素我理解这个就是像比于set，insert的时候增加了一维时间戳。两者其内部的实现为一颗红黑树。 set multiset 定义12set&lt;类型&gt; 名字;multiset&lt;类型&gt; 名字; 举个例子来说: 12345set&lt;int&gt; s;set&lt;set&lt;int&gt; &gt; ss;set&lt;pair&lt;int,int&gt; &gt; ps;set&lt;vector&lt;int&gt; &gt; vs;multiset&lt;double&gt; ms; 如果我们需要自己定义类型的话需要自己定义友元函数来重载运算符，与排序是一样的，例如: 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int x,y; friend bool operator &lt; (node A,node B)&#123; //和 sort 定义 cmp 函数是一样的 if(A.x==B.x)&#123; return A.y&lt;B.y; &#125; return A.x&lt;B.x; &#125;&#125;;int main(void) &#123; node a,b; a.x=1;a.y=2; b.x=1;b.y=3; set&lt;node&gt; A; A.insert(a); A.insert(b); auto x=*A.begin(); cout&lt;&lt;x.x&lt;&lt;" "&lt;&lt;x.y&lt;&lt;endl; x=*(++A.begin()); cout&lt;&lt;x.x&lt;&lt;" "&lt;&lt;x.y&lt;&lt;endl;&#125;output:1 21 3 size函数表示set中的元素个数，返回一个整形变量，时间复杂度为$O(1)$ 使用方式： 1printf("%d",(int)s.size()); clear函数清空一个集合，无返回值 使用方式: 1s.clear() count函数返回set中的值为$x$的元素个数，时间按复杂度为$O(\log n+an)$ 使用方式： 1printf("%d\n",s.count(x)); 迭代器set的迭代器是双向的，支持—,++两种操作。若把 ite++ ，则 ite 将会指向“下一个”元素。这里的下一个是指在 key从小到大排序的结果中，排在ite 下一名的元素。同理，若把ite— ，则 ite会指向排在上一个的元素。“++”，“—”操作的复杂度均为$O (\log n)$。 使用方式： 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;set&lt;int&gt;::iterator ite;int main(void) &#123; s.insert(4); s.insert(5); ite=s.begin(); cout&lt;&lt;*ite&lt;&lt;endl; ite++; cout&lt;&lt;*ite&lt;&lt;endl; ite--; cout&lt;&lt;*ite&lt;&lt;endl;&#125;output:454 begin函数表示集合的首迭代器，时间复杂度$O(1)$ 使用方式： 1cout&lt;&lt;*s.begin()&lt;&lt;endl; end函数由于STL都是左闭右开的，那么end返回的位置其实是类似于string中\0的位置，所以我们需要—，才能得到最大的元素的迭代器。其实s.end()存储的是集合中的元素个数 使用方式： 1cout&lt;&lt;*(--s.end())&lt;&lt;endl; 遍历我们通过++运算符以及begin函数和end函数来进行遍历整个集合 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;set&lt;int&gt;::iterator ite;int main(void) &#123; s.insert(4); s.insert(5); for(ite=s.begin();ite!=s.end();ite++)&#123; cout&lt;&lt;*ite&lt;&lt;endl; &#125;&#125; insert函数向set中插入元素，返回值为插入地址的迭代器以及是否插入成功所组成的pair，时间复杂度为$O(\log n)$使用方式： 1s.insert(5); erase函数删除，参数可以是元素或者迭代器，返回下一个元素的迭代器，时间复杂度为 O(log n)，注意在 multiset 中 s.erase(x)会删除所有值为 $x$ 的元素。所以在multiset中一般是和find函数一起使用的。 使用方式: 12s.erase(4);s.erase(s.find(5)); find函数在集合中找到第一个元素值等于$x$的迭代器，若不存在的话，返回s.end()。时间复杂度为$O(\log n)$ 123if(s.find(3)!=s.end())&#123; cout&lt;&lt;"yes"&lt;&lt;endl;&#125; lower_bound和upper_bound函数用法与$find$类似，但查找的条件略有不同，时间复杂度 $O(\log n)$。和vector当中的几乎一样。 $s.lower_ bound(x)$表示查找 $&gt;=x$的元素中最小的一个，并返回指向该元素的迭代器。 $s.upper_ bound(x)$表示查找 $&gt;x$ 的元素中最小的一个，并返回指向该元素的迭代器。 例如： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;set&lt;int&gt; s;set&lt;int&gt; ::iterator ite;int main(void) &#123; int a[]=&#123;3,4,6,7,9&#125;; for(int i=0;i&lt;5;i++)&#123; s.insert(a[i]); &#125; ite=s.lower_bound(4); cout&lt;&lt;*ite&lt;&lt;endl;//4 ite=s.upper_bound(4); cout&lt;&lt;*ite&lt;&lt;endl;//6 ite=s.lower_bound(8); cout&lt;&lt;*ite&lt;&lt;endl;//9 ite=s.upper_bound(8); cout&lt;&lt;*ite&lt;&lt;endl;//9 ite=s.lower_bound(9); cout&lt;&lt;*ite&lt;&lt;endl;//9 ite=s.upper_bound(9); cout&lt;&lt;*ite&lt;&lt;endl;//s.end(); 5 ite=s.lower_bound(99); cout&lt;&lt;*ite&lt;&lt;endl;//s.end(); 5 ite=s.upper_bound(99); cout&lt;&lt;*ite&lt;&lt;endl;//s.end(); 5&#125;/*output:46999555*/ mapmap表示一个映射，这是非常有用的东西。其主要分为两部分表示的是一个偏序对，左边key为键值，右边value为映射值。 定义1map&lt;key类型，value类型&gt; 名字 举个例子： 1234map&lt;int,int&gt; ii;map&lt;int,double&gt; id;map&lt;long long,double&gt; Ld;map&lt;vector&lt;int&gt; ,vector&lt;int&gt; &gt; vv; 如果我们需要自定义类型的话，和前面的set一样自己定义友元函数重载运算符即可。 size函数表示map中存储了多少对映射，时间复杂度$O( 1 )$ 使用方式： 1cout&lt;&lt;ma.size()&lt;&lt;endl; 插入方式类似数组一样的使用方式，使用[]来进行插入。使劲按复杂度是$O(\log n )$ 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt; ma;int main(void) &#123; ma["a"]=3;//表示"a"映射为3 ma["b"]=312;//表示"a"映射为312 ma["c"]=43;//表示"a"映射为43 cout&lt;&lt;ma["a"]&lt;&lt;endl; cout&lt;&lt;ma["b"]&lt;&lt;endl; cout&lt;&lt;ma["c"]&lt;&lt;endl;&#125; 迭代器使用与set一样的方式进行遍历，定义迭代器，但是相应不同的地方就是first与second的用法。其中++,—操作的时间复杂度也是$O(\log n)$的。 注意，map中的end迭代器是真的没有用的。我们必须要进行特判 123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,int&gt; ma;map&lt;string,int&gt;::iterator ite;int main(void) &#123; ma["a"]=3;//表示"a"映射为3 ma["b"]=312;//表示"a"映射为312 ma["c"]=43;//表示"a"映射为43 for(ite=ma.begin();ite!=ma.end();ite++)&#123; cout&lt;&lt;ite-&gt;first&lt;&lt;" "&lt;&lt;ite-&gt;second&lt;&lt;endl; &#125;&#125; lower_bound和upper_bound函数map在调用这些函数的时候，是二分查找键值。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;int,int&gt; ma;map&lt;int,int&gt;::iterator ite;int main(void) &#123; int i,a[]=&#123;3,4,6,7,9&#125;; for(i=0;i&lt;5;i++)&#123; ma[a[i]]=i; &#125; ite=ma.lower_bound(4); if(ite!=ma.end()) cout&lt;&lt;ite-&gt;first&lt;&lt;" "&lt;&lt;ite-&gt;second&lt;&lt;endl; ite=ma.upper_bound(4); if(ite!=ma.end()) cout&lt;&lt;ite-&gt;first&lt;&lt;" "&lt;&lt;ite-&gt;second&lt;&lt;endl;&#125;output:4 16 2 vectorvector是stl中封装好的动态数组实现方式。其有一些特性，我们不妨看看。其中我们需要知道以下两个函数。 size() capacity() clear() 前者表示当前的vector存储了多少个数值，时间复杂度为$O(1)$，中者表示的是当前的vector申请类多少内存，后者表示清空当前的vector。 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a;int main(void) &#123; int i; for(i=0;i&lt;15;i++)&#123; cout&lt;&lt;"now size "&lt;&lt;a.size()&lt;&lt;" now capacity "&lt;&lt;a.capacity()&lt;&lt;endl; a.push_back(i); &#125; a.clear(); cout&lt;&lt;"now size "&lt;&lt;a.size()&lt;&lt;" now capacity "&lt;&lt;a.capacity()&lt;&lt;endl;&#125;/*now size 0 now capacity 0now size 1 now capacity 1now size 2 now capacity 2now size 3 now capacity 4now size 4 now capacity 4now size 5 now capacity 8now size 6 now capacity 8now size 7 now capacity 8now size 8 now capacity 8now size 9 now capacity 16now size 10 now capacity 16now size 11 now capacity 16now size 12 now capacity 16now size 13 now capacity 16now size 14 now capacity 16now size 0 now capacity 16*/ 我们运行上面的代码可以发现vector数组是倍增的，同时clear函数不会改变申请的内存的容量。 sort函数排序的方式相对也比较简单，具体来说有几种方式。 默认的类型时使用greater方法 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a;int main(void) &#123; int i; for(i=0;i&lt;15;i++)&#123; a.push_back(rand()); &#125; //sort(a.begin(),a.end());//增序 sort(a.begin(),a.end(),greater&lt;int&gt;());//降序 for(i=0;i&lt;15;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125;&#125; 定义cmp函数 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a;int cmp1(int x,int y)&#123; return x&lt;y;//增序&#125;int cmp2(int x,int y)&#123; return x&gt;y;//降序&#125;int main(void) &#123; int i; for(i=0;i&lt;15;i++)&#123; a.push_back(rand()); &#125; //sort(a.begin(),a.end(),cmp1); sort(a.begin(),a.end(),cmp2); for(i=0;i&lt;15;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;endl; &#125;&#125; 友元函数重载运算符 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;struct node &#123; int x,y; friend bool operator &lt; (node A,node B)&#123; return A.x&lt;B.x; &#125;&#125;;vector&lt;node&gt; a;int main(void) &#123; int i; node t; for(i=0;i&lt;15;i++)&#123; t.x=rand(); t.y=rand(); a.push_back(t); &#125; sort(a.begin(),a.end()); for(i=0;i&lt;15;i++)&#123; cout&lt;&lt;a[i].x&lt;&lt;" "&lt;&lt;a[i].y&lt;&lt;endl; &#125;&#125; 二维数组的定义方式vector不同于正常的数组，它的类型可以是任意的。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;set&lt;int&gt; &gt; vec; //定义元素为set的数组vector&lt;vector&lt;int&gt; &gt; vec; //定义二维数组vector&lt;int&gt; vec[100]; //定义一个[100][x]的数组。int main(void) &#123; int i; set&lt;int&gt; a; a.clear(); for(i=0;i&lt;10;i++)&#123; a.insert(i); vec.push_back(a); &#125; for(i=0;i&lt;10;i++)&#123; printf("%d\n",vec[i].size()); &#125; for(i=0;i&lt;10;i++)&#123; vec[i].insert(100); printf("%d\n",vec[i].size()); &#125;&#125; lower_lound()这个函数是用于在数组中进行二分的函数，十分常用。 其功能很简单，对于参数$x$，在数组中找第一个$&gt;=x$的数的地址。时间复杂度是$O(\log n)$ 下面将演示其的用法： 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; vec;int main(void) &#123; int i; vec.clear(); for(i=0;i&lt;20;i+=2)&#123; vec.push_back(i);//0 2 4 8 ... 18 &#125; // 用法 lower_bound(vec.begin(),vec.end(),x) 表示数组的起始位置，终止位置，和参数x // 返回的是地址。 printf("ans=%d\n",*lower_bound(vec.begin(),vec.end(),3)); //加星号变成具体数值 4 printf("ans=%d\n",*lower_bound(vec.begin(),vec.end(),4)); //减去初始位置，等于下标 // 变成下标 printf("ans=%d\n",*lower_bound(vec.begin(),vec.end(),14)); //加星号变成具体数值 14 printf("position=%d\n",lower_bound(vec.begin(),vec.end(),14)-vec.begin()); //减去初始位置，等于下标 // 特殊情况下 越界了 printf("vec_size=%d\n",vec.size()); //这里的答案不对。 printf("ans=%d\n",*lower_bound(vec.begin(),vec.end(),100)); //加星号变成具体数值 printf("position=%d\n",lower_bound(vec.begin(),vec.end(),100)-vec.begin()); //减去初始位置，等于下标值 int pos=lower_bound(vec.begin(),vec.end(),100)-vec.begin(); // 特判一下就好了 if(pos==vec.size())&#123; printf("ATTENTION: there is no answer!"); &#125;&#125; upper_bound()这个函数是用于在数组中进行二分的函数，十分常用。 其功能很简单，对于参数$x$，在数组中找第一个$&gt;x$的数的地址。时间复杂度是$O(\log n)$这个常用于统计一个数在有序数组中出现的次数。 下面将演示其的用法，几乎和lower_bound一模一样： 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; vec;int main(void) &#123; int i; vec.clear(); for(i=0;i&lt;20;i+=2)&#123; vec.push_back(i);//0 2 4 6 8 ... 18 &#125; for(i=0;i&lt;20;i+=4)&#123; vec.push_back(i);//0 4 8 ... 16 &#125; sort(vec.begin(),vec.end()); // 用法 upper_bound(vec.begin(),vec.end(),x) 表示数组的起始位置，终止位置，和参数x // 返回的是地址。 printf("ans=%d\n",*upper_bound(vec.begin(),vec.end(),3)); //加星号变成具体数值 4 printf("ans=%d\n",*upper_bound(vec.begin(),vec.end(),4)); //减去初始位置，等于下标 // 变成下标 printf("ans=%d\n",*upper_bound(vec.begin(),vec.end(),14)); //加星号变成具体数值 16 printf("position=%d\n",upper_bound(vec.begin(),vec.end(),14)-vec.begin()); //减去初始位置，等于下标 12 // 统计一个数出现的次数,和lower_bound结合使用 printf("cnt=%d\n",upper_bound(vec.begin(),vec.end(),14)-lower_bound(vec.begin(),vec.end(),14));//1 printf("cnt=%d\n",upper_bound(vec.begin(),vec.end(),16)-lower_bound(vec.begin(),vec.end(),16));//2 // 特殊情况下 越界了 printf("vec_size=%d\n",vec.size()); //这里的答案不对。 printf("ans=%d\n",*upper_bound(vec.begin(),vec.end(),100)); //加星号变成具体数值 printf("position=%d\n",upper_bound(vec.begin(),vec.end(),100)-vec.begin()); //减去初始位置，等于下标 int pos=upper_bound(vec.begin(),vec.end(),100)-vec.begin(); // 特判一下就好了 if(pos==vec.size())&#123; printf("ATTENTION: there is no answer!"); &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制HASH]]></title>
    <url>%2FHash%2F</url>
    <content type="text"><![CDATA[HASH为了加速字符串的检索。我们通常采用的方法是对字符串进行加密，加密的方式有很多种，有单纯为了检索是否原串存在的，有加密后再解密的算法(典型的就是RSA公钥私钥算法)。本文讨论第一种，就是检索原串是否存在。 Hash的基本思想哈希算法其实是一种概率算法，它希望我们对串进行一系列操作，使得每一个串都能对应一个独一无二的数。我们知道64位计算机最大能存储的数为18446744073709551615，也就是$2^{64}-1$，这其实已经是一个相当大的数了。假如我们只有$10^{15}$个串的话，我们希望每个串对应上面中的一个数，冲突的概率其实是无限接近于0的。但是我们要知道$10^{15}$其实是一个相当大的数了，基本上完全可以满足我们的需求。于是我们希望对字符串设计一种方法，使得字符串的对应的值尽量唯一。 进制hash一种十分经典的思想就是进制哈希，这种哈希方式写起来十分简单，意思就是我们将原字符串就视为一个其他进制的数，之后我们用二进制表示这个数，就得到了一个很好的hash结果。我们在操作过程中通常取原串的进制为131。采用unsigned long long方式存储，自然溢出得到结果，当然不自然溢出也是可以的。因为从概率来说几乎都是不存在冲突的可能。除非刻意构造数据。 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;ull prime=1000000007,base=131;ull mod=212370440130137957ll;ull HASH(string s)&#123; ull ans=0; for(int i=0;s[i];i++)&#123; ans=(ans*base+(ull)s[i])%mod+prime; &#125; return ans;&#125;int main(void)&#123; ull a; string s; while(1)&#123; cin&gt;&gt;s; cout&lt;&lt;HASH(s)&lt;&lt;endl; &#125;&#125; 多重进制hash有时候我们为了进一步减少冲突，往往采用好几组$base$和$prime$。如果对每一组$base$和$prime$都一样的话，我们才认为相同，正确性也是显然的。在采用多组的$base$和$prime$之后，几乎是找不到冲突的数据的。实现起来也很简单。 1234567891011121314151617181920212223ull ans[100005][5];ull p[]=&#123;&#125;,BASE[]=&#123;&#125;;void MULTIHASH(int x,string s)&#123; int i,j; for(i=0;i&lt;5;i++)&#123; ans[x][i]=0; &#125; for(i=0;s[i];i++)&#123; for(j=0;j&lt;5;j++)&#123; ans[x][j]=(ans[x][j]*base[j]+(ull)s[i])%mod+prime; &#125; &#125;&#125;int main(void)&#123; ull a; string s; int n; cin&gt;&gt;n; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;s; MULTIHASH(i,s); &#125;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>HASH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性基]]></title>
    <url>%2FLinearBase%2F</url>
    <content type="text"><![CDATA[线性基我们在碰到XOR问题的时候，通常难以下笔。这是因为XOR问题的解法通常难以构造，直观上建模比较困难。为了解决这一类问题，线性基由此而提出。通过我们所熟知的XOR的一些完美的性质，于是我们可以把一堆数压缩成64个数，可以保证这64个数的异或结果的值域与原数组的值域一样。而这个压缩的过程就是线性基的构造过程，我们理解起来也很简单。 基上面所说的压缩成64个数也许你会有一些疑问，我们不妨设想，现在有一组二进制基:1，10，100，1000，…。我们其实可以通过这一些基相互异或得到$[0,2^{64}-1]$区间内所有的数。但是我们需要构造与原数组所有子集异或值域一样的基，就被称作线性基，线性基保证了产生的基的个数最少。类似于线性代数中的极大无关组。所谓基的概念也是从线性代数中引用过来的。 构造方法1首先我们申请一个数组$base[64]$，对于$base[i]$而言存储的是二进制中最高位的1在第$i$位的数。64表示二进制的数位，最高为64位，可以向上叠加。 我们对原数组中每一个数$x$，从高位到低位遍历，若当前最高位$i$为1，我们检查$base[i]$是否有值，有值的话，我们令$x=x$^ $base[i]$，否则我们令$base[i]=x$ 构造代码1123456789101112131415long long base[100];scanf("%lld",&amp;n);for(i=0; i&lt;n; i++) &#123; scanf("%lld",&amp;a); for(j=63; j&gt;=0; j--) &#123; if(a&amp;(1LL&lt;&lt;j)) &#123; if(base[j]) &#123; a^=base[j]; &#125; else &#123; base[j]=a; break; &#125; &#125; &#125;&#125; 构造方法2使用高斯消元的方法进行求线性基，这种构造线性基的方式相对麻烦一些，但是它保证了一个非常良好的性质，就是保证了，线性基的异或值从高位到低位的结果是单增的，我们使用这种线性基的话，很容易解决XOR求取第$k​$大问题。构造过程和构造方法1十分类似。 构造代码21234567891011121314151617181920212223242526long long a[10005];int n;scanf("%d", &amp;n);for (int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;a[i]);&#125;int m = 60;int dim = 0;for (int i = m - 1; i &gt;= 0; i--) &#123; int t = -1; for (int j = dim; j &lt; n; j++) &#123; if (a[j] &gt;&gt; i &amp; 1) &#123; t = j; break; &#125; &#125; if (t == -1) continue; if (t != dim) swap(a[dim], a[t]); for (int j = 0; j &lt; n; j++) &#123; if (j != dim &amp;&amp; (a[j] &gt;&gt; i &amp; 1)) &#123; a[j] ^= a[dim]; &#125; &#125; dim++;&#125;//最后的0-dim维就是求得的线性基，这里升序排序。 线性基的性质线性基的任何一个非空子集都不会使得其$xor​$和为0，证明方法使用反证法即可。这个性质可以保证线性基的算法的合法性。 来解决一些问题吧异或最大值问题给我们一堆数，我们希望知道哪些数相互异或后结果最大，输出最大的值即可。 解法我们使用首先构造线性基，初始化$ans=0$，之后对于线性基从高位向低位扫，若当前的$base[i]$与ans异或后结果更大，那么就异或。否则跳过这一位即可。 若我们使用第二种线性基构造方式，将得到的线性基全部异或起来就好了。 异或判断问题给我们一堆数，再给我们一个数$x$，判断$x$是否可以由这些数的一个子集异或得到。 解法我们首先构造线性基，之后对于$x$，我们只需要对于$x$从高位到低位每个1与$base[i]$异或即可，若最后$x$的值为0，那么就可以被构造出来，否则无法被构造出来。其实意是也是很简单的，就相当于插入过程，如果$x$不需要导出新的$base[i]$，说明$x$无用，那么就一定可以被构造出来。否则需要导出新的$base[i]$来辅助构造$x$。 CF1011G将原数组分为几段，每段内异或得到一个值，且任何一些连续段的异或值都不为0，最多能够划分多少段？ 解法这个题目用到了上文介绍到的性质，线性基的任何一个非空子集都不会使得其$xor$和为0。于是本题的答案就是构造线性基的结果中,$base[i]$不为0的个数。 异或种数问题给我们一堆数，问这些数的所有子集异或所得到的数有多少种？ 解法答案就是2^线性基中基的个数。 一堆数中第k大的异或值问题给我们一堆数，我们可以从中挑一些数出来，进行异或，这样的话我们可以得到很多不同的异或值，问我们第k大的结果是什么？ 解法这个题目我们只能使用第二种线性基构造方式构造线性基，特判0的存在之后，将k的每一位为1的相应的线性基对应的值异或起来就好了。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>codeforces</tag>
        <tag>LinearBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小问题集合-长期更新]]></title>
    <url>%2FProblemSet%2F</url>
    <content type="text"><![CDATA[这是一些有意思的小问题，长期更新题目 现在有$n$类钞票，每种有无限张，我们从中带走一些钞票。给定一个数$k$，希望我们保证$[1,k]$这个面值区间的每一个数我们都可以从带走的钞票中凑出来。问对于给定的$k$，我们至少要需要带走几张钞票，不能满足输出$-1$。$n&lt;1e5,k&lt;1e9$ 给定一个$1$到$n$的排列，求一个子序列使得其逆序对数与长度比值最大，输出这个比值。$n&lt;100$ 给定两个1到$n$的排列，求这两个排列的最长公共序列。$n&lt;1e5$ 给定一个$n*n$矩阵，其中数字各不相同，找到一个矩阵的局部最小(大)值的坐标输出即可。$n&lt;1e5$ 给出$n$个数，这些数互不相同，我们希望删除其中的一个数，使得剩余的所有数异或和最大。$n&lt;1e 5$ 给出$n$个数，这些数互不相同，我们希望删除其中的两个数，使得剩余的所有数异或和最大。$n&lt;1e 5​$ 给出$n+1$个数，每个数都在$[1,n]$之间，且只有一个数出现两次，要求$O(n)$时间$O(1)$空间找出。 给$n$个数，保证存在唯一一个出现奇数次的数，找到这个数。$n&lt;1e5$ 给$n$个数求最大最小数。比较次数控制在$1.5n$次之内。 在一大堆数中求top100，要求时间复杂度小于$O(nlogn)$ 一堆数中，找出那个出现次数大于n/2的数。 现在有8个球，每个球长的一样，其中7个质量相同，有1个比较重，现在有一个天平，左右可以放任意个球，问我们最少称几次可以找到重的那个球。 解法 我们使用贪心的思想，有一个小trick就是我们对于选中的数集的和$sum$而言，我们下一次选的数一定是在$sum+1$之内的，所以只需要每次贪心的选取就可以了。时间复杂度$O(\log k)$。 遇到这种比值的且$n$较小的，一般都是最大密度子图问题，这个就是一个裸题，但是很多时候我们往往想不到。时间复杂度$O(E100^2)$ 由于排列当中没有相同的数字，那么我们可以把问题变成最长上升序列问题。时间复杂度$O(n\log n)$ 这个题目明显是一道分治的题目，我们可以每次递归问题到一个小矩阵，做法很简单，我们至于需要见检查中间一列，中间一行是否有数满足条件，若满足条件，输出。不满足条件，向检查过程中最小值(一定在小矩阵内部)出现的那一个矩阵进行递归即可。时间复杂度$O(n)$ 我们在原数组中删除一个数$x$，相当于在数组中添加一个数$x$。这是异或有意思的性质。于是我们直接拿最初的异或结果$sum$，向原数组中的每个数异或一遍得到最大的结果就可以了。时间复杂度$O(n)$ 我们在原数组中删除两个数$x，y$，相当于在数组中添加两个数$x，y$。我们首先构造一个01字典树,树高为64。于是我们直接拿最初的异或结果$sum$，向原数组中的每个数异或，接下来我们只需要按照异或结果的反方向在树上走一遍就好了，之后我们可以得到答案。时间复杂度$O(64n)$ 我们只需要对原数组求和之后减去$n*(1+n)/2$即可。时间复杂度$O( n )$ 我们只需要对原数组的所有数异或一边即可。时间复杂度$O( n )​$ 我们对$n$进行两两分组，之后两个数之间先确定大小。再与当前最大值与当前最小值进行比较，即这里可以省去不必要的比较。 我们固定一个大小为100的小根堆，每次插入，调整，删除即可。时间复杂度$O(nlog100)$ 解法多种多样，第一种，每次随机一个下标，之后看当前的数是不是满足条件，期望随机次数只有两次。第二种类似大乱斗的思想，使用一个计数器计数，碰到一样的加，不一样的减，若为计数器负数，那么修改计数器需要统计的数，最后剩下的就是满足的数。理解起来很简单，假设一样的数是一个军团，其他数是另一个军团，每个士兵可以一换一，那么最后剩下来的那个就是人数最多的军团。 首先我们可以想到二分法，这样的话我们会脱口而出答案是3。但是这个想法是错的，实际上我们只需要2次就可以了！首先我们可以考虑一下3个球的情况，这个时候我们只需要称一次就行了！对于8的时候，我们只需要称2次即可。实际上这个题目是一个dp的题目， 我们每次分成3份，假设每份数量为X,X,Y且X+X+Y=n，其中两份X表示要放天平上称的那两份，之后每次根据称重结果进行递推就行了。简单来说，如果不平衡的话，就递归下沉的那一堆，如果平衡的话，就递归还没称的那一堆。递推方程式如下： dp[n]=min(dp[n],max(dp[i],dp[n-2\cdot i])+1)]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Nice-Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题]]></title>
    <url>%2FMinDistance%2F</url>
    <content type="text"><![CDATA[最短路问题最短路问题是一类十分典型的图论问题，给定一个图，求起点$s$至终点$t$的最短路径。使用数学语言描述为： 给定图$G(V,E)$ $e=(from,to,distance)\in E$ 表示边集$E$中的边有三个参数表示起点，终点，距离 $s,t\in V$ 起点终点都属于点集$V$，求最短距离$MinDis(s,t)$ 这类问题理解起来也很简单，典型的问题就是火车买票问题，求上海到北京怎么买票花费最少，或者用时最短，这都可以建模为最短路问题。关于最短路问题，分为两类： 单源最短路 多源最短路 虽然多源最短路可以通过多次调用单源最短路的算法达到效果，但是对于一些算法的出发点是不同的，所以还是归为两类。对于多源最短路问题，最典型的算法是Floyd算法，通过$O(V^3)$的时间可以求出来任意两点的最短路径。对于单源最短路问题，方法多种多样，代表性的算法是Bellman-ford、Spfa、Dijkstra。本文将会依次介绍上述4种算法。 Bellman-ford我们按照时间顺序介绍上述算法，在1956年，提出了第一个基于动态规划思想的最短路算法Bellman-ford。这个算法为后面的所有算法打下了理论基础，所以Bellman-ford算法是一个非常值得我们仔细思考的算法。 首先回到我们的问题，我们希望求$s-t$的最短路径，由于我们中间最多有$V-2$个节点，经过$V-1$条不同路径，那么我们相当于我们从$s$出发，每次尝试一下$V$种节点，那么我们总共会有$(V-1)^{V}$可能的路径，这个估计明显是个上界，显然是不可解的。于是我们采用动态规划化简上面的求解过程，仔细想想，这个过程和和隐马尔可夫模型中的Viterbi算法的过程一样。，所以我认为Viterbi算法(1967年提出)极大的受到了Bellman-ford算法的启发现在看来神经网络还真是玄学啊，感觉和之前的算法没什么共通性我们定义状态转移方程： dp[i][step]=min(dp[i][step-1],dp[j][step-1]+dis[j][i])\quad j=1,2,3,...,n上面的dis数组表示节点$j$与节点$i$之间的距离。step表示当前最多允许通过几个节点。 注意：我们使用Bellman-ford算法还有一个原因，就是Bellman-ford可以用来判断负环，负环的意思就是说网络中存在一个环，环上的边的所有权值相加为负数。这样的话，我们找最短路，就可以一直沿着这个环走，从而得到一个无穷小的值，但是这显然是不合理的。所以我们可以通过Bellman-ford算法进行检测，检查的方式也很简单，我们在运行了$V-1$次程序之后，再运行一次，如果存在负环的话，那么我们对每个环至少可以走一圈，也就是说，如果还有节点的最短距离可以继续缩短的话，那么就存在负环，否则就不存在。请好好思考为什么，如果不明白这个，那么我只能说你还没有掌握到Bellman-ford算法的精髓。 代码实现本文的代码能够AC HDU-2544。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int,int&gt; &gt; vec[1005];//end-distanceint dp[1005][1005],n,m,INF=1e9+7;int BellmanFord(int s,int t) &#123; int i,j,step; for(i=0; i&lt;n; i++) &#123; for(j=0; j&lt;n; j++) &#123; dp[i][j]=INF; &#125; &#125; for(i=0; i&lt;n; i++) &#123; dp[s][i]=0; &#125; for(step=1; step&lt;n; step++) &#123; for(i=0; i&lt;n; i++) &#123; for(auto x : vec[i]) &#123; dp[i][step]=min(dp[i][step],min(dp[i][step-1],dp[x.first][step-1]+x.second)); &#125; &#125; &#125; return dp[t][n-1];&#125;int main(void) &#123; int i,j,a,b,c; while(scanf("%d %d",&amp;n,&amp;m)!=EOF) &#123; if(n==0&amp;&amp;m==0) break; for(i=0; i&lt;n; i++) &#123; vec[i].clear(); &#125; for(i=0; i&lt;m; i++) &#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); a--; b--; vec[a].push_back(make_pair(b,c)); vec[b].push_back(make_pair(a,c)); &#125; printf("%d\n",BellmanFord(0,n-1)); &#125;&#125; 时间复杂度分析很明显Bellman-ford算法需要更新$V-1$次，同时每一次我们需要对每条边进行检查，时间复杂度为$O(VE)$ SpfaSpfa的全称是shortest path faster algorithm。这个算法的名字倒还是蛮中肯，并没有说是fastest。这个算法也是一种单源最短路径算法，其本质是对Bellman-ford算法的队列优化。它省去了一些冗余操作。其想法主要在Bellman-ford的计算方式上。我们再次看看状态转移方程： dp[i][step]=min(dp[i][step-1],dp[j][step-1]+dis[j][i])\quad j=1,2,3,...,n我们很可能存在这样一种情况，对于第$step$轮循环来说$dp[j][step-1]$的值和第$step-1$的$dp[j][step-1]$是一样的，同时我们在上一轮已经计算过了，那么对于这一轮来说，再计算完全是浪费的计算，我们可不可以减少这样的冗余计算呢？ 其实改进的方式也很简单，我们在递推过程中，如果当前的最短距离的值减小了，我们才用这个减小的值去更新别的值，直到所有的节点的距离不再减小。换句话说，当我们检查到当前的节点的最短距离变小了，我们才用这个最短距离去检查是不是能让其相邻节点的最短路也减小距离，请注意我们并不是立即更新，而是放入队列进行等待，依次更新，这样是有很大好处的，请仔细想想为什么我们会这样操作。我们每次更新的这种操作也叫松弛操作。 注意：Spfa也是可以判断负环的，判断的方式也很简单，只需要对每个节点检查入队次数即可，因为一个节点入队的次数是不会超过$n$次的，所以当一个点入队次数超过$V$，就肯定存在负环。因为一个点到源点的距离不可能被更新$V$次，因为路径上最多只有$V-1$个节点，不存在还有其他节点能够再松弛距离。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;pair&lt;int,int&gt; &gt; vec[1005];int dp[1005],n,m,INF=1e9+7,vis[1005];queue&lt;int&gt; que;int Spfa(int s,int t)&#123; int i,T; for(i=0; i&lt;n; i++) &#123; dp[i]=INF; &#125; dp[s]=0; que.push(s); vis[s]=1; while(que.size())&#123; T=que.front(); vis[T]=0; que.pop(); for(auto x : vec[T])&#123; if(dp[x.first]&gt;dp[T]+x.second)&#123; dp[x.first]=dp[T]+x.second; if(!vis[x.first])&#123; vis[x.first]=1; que.push(x.first); &#125; &#125; &#125; &#125; return dp[t];&#125;int main(void) &#123; int i,j,a,b,c; while(scanf("%d %d",&amp;n,&amp;m)!=EOF) &#123; if(n==0&amp;&amp;m==0) break; for(i=0; i&lt;n; i++) &#123; vec[i].clear(); &#125; for(i=0; i&lt;m; i++) &#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); a--; b--; vec[a].push_back(make_pair(b,c)); vec[b].push_back(make_pair(a,c)); &#125; printf("%d\n",Spfa(0,n-1)); &#125;&#125; 时间复杂度分析Spfa的时间复杂度不是很好分析。。虽然Spfa大部分时候都比较快，但是某些精心构造的图上可以让spfa跑的很慢，目前证明的结果是Spfa的时间复杂度和Bellman-ford是一样的，最坏情况下时间复杂度为$O(VE)$。但是对于大部分含有噪声的数据上跑的还是很快，这也是我们为什么说噪声是个好东西，实际会让你的算法效果变的更优。 Flody弗洛依德算法是一个多源最短路径算法，这个算法的发明人曾是一个文科专业毕业的学生，由于难以找到工作，转行计算机，但是却在计算机行业干的风生水起，最后走上人生巅峰拿了图灵奖。废话说了一堆，让我们聊一聊这个大名鼎鼎的算法，这个算法美就美在它只用了几行代码就实现了多源最短路。废话不多说，先看代码。 代码实现1234567int floyd(int s,int t)&#123; for(k=0;k&lt;n;k++) for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); return dis[s][t];&#125; 没错，就是这么简单粗暴，代码就是这么精简，但是却实现多源最短路这个神奇的任务，这是为什么呢？很多人都会说Flody算法没什么啊，很显然啊，就是对每个点都中转一次而已，没什么难度。但是事实真的是这么显然吗？为什么我没看出来？既然都是中转一遍，为什么k一定要在外层，我可以把k放在里层吗？也请读者你再带着怀疑的眼光再观察这份代码，好好想想，我觉得很有可能出现$dis[i][k]$并没有达到最优情况或者$dis[k][j]$没有达到最优情况。请在思考后再看下面的解释，我认为这会更加帮助你理解Floyd那精妙的想法。 时间复杂度分析简单粗暴的$O(V^ 3)$的时间复杂度，其实对于多源最短路来说，这个复杂度并不糟糕，我们调用$V$次Bellman-ford所需要花的时间是$O(V^2E)$但是$E$在稠密图的话，量级是趋于$V^2$的，所以对比最坏情况来说，Floyd算法不仅在数量级上取得了质的改变，同时代码的量也极其精简。 正确性证明Floyd算法的正确性真的就这么显然吗？我不是这么认为的，现在我们使用数学方法来说明为什么这样写是正确的。 我们假设源点$i$到汇点$j$中最优路径需要经过的最大节点为$x$。我们需要说明在$k=x$这一轮结束后，$dis[i][j]$一定得到了最小值。也就是说$dis[i][k],dis[k][j]$已经为最小值了。其实到此为止我们就已经发现最优子结构了，原本是不需要再往下解释的，但是我们再详细解释一下。 假设我们此时对$dis[i][k]$继续进行递归。而此时最大的为$x1$。我们可以知道$x1&lt;x$，再进行递归下去。 最后我们可以得到$x_n$是最小的需要经过的节点，而这个节点肯定是与$s$直接连接，而无法被减小的。那么我们可以回到上一层，通过这样的归纳，我们可以证明$dis[i][k]$与$dis[k][j]$一定是最小值。那么$dis[i][j]$通过$k=x$这一轮循环，一定可以得到最小值。 DijkstraDijkstra算法，就是目前最常使用的单源最短路算法，他的想法也是从Bellman-ford算法得到的，他通过仔细观察Bellman-ford算法的计算过程，总结出了一个极其优美的规律，那就是我们每一轮的松弛操作只需要对当前距离源点$s$最近的且没有被访问过的节点开始松弛就可以了，其他的节点我们不需要松弛。但是这是为什么呢？我的理解是因为我们既然做Bellman-ford的松弛操作。我们肯定是希望和spfa那样，选择最有可能减小其他节点的最短路的点去进行松弛操作，而这个点就是最近的且没有被访问过的节点。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int dis[1005],vis[1005],ma[1005][1005],INF=1e9+7,n,m;int dijstra(int x,int y)&#123; int i,j,t; for(j=1;j&lt;=n;j++) dis[j]=ma[x][j]; memset(vis,0,sizeof(vis)); vis[x]=1; while(true)&#123; t=-1; for(i=1;i&lt;=n;i++)&#123; if(dis[i]!=INF&amp;&amp;!vis[i])&#123; if(t==-1||(dis[t]&gt;dis[i])) t=i; &#125; &#125; if(t==-1) break; vis[t]=1; for(i=1;i&lt;=n;i++)&#123; dis[i]=min(dis[i],dis[t]+ma[t][i]); &#125; &#125; return dis[y];&#125;int main(void)&#123; int T,i,j,a,b,c,t,res; while(scanf("%d %d",&amp;n,&amp;m)!=EOF)&#123; if(n==0&amp;&amp;m==0) break; for(i=0;i&lt;1005;i++)&#123; for(j=0;j&lt;1005;j++)&#123; ma[i][j]=INF; &#125; &#125; for(i=0;i&lt;m;i++)&#123; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); ma[a][b]=min(ma[a][b],c); ma[b][a]=ma[a][b]; &#125; res=dijstra(1,n); printf("%d\n",res); &#125;&#125; 时间复杂度分析上面的代码是最简单的dijkstra实现的方法，采用的是邻接矩阵存储。时间复杂度为$O(n^2)$。当然我们可以采用二叉堆、Binomial堆、斐波那契堆进行优化，得到$O(n\log n)​$级别的Dijkstra算法。在此不再赘述。]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>graph-theory</tag>
        <tag>Bellman-ford</tag>
        <tag>Dijkstra</tag>
        <tag>Spfa</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大流问题]]></title>
    <url>%2FMaxFlow%2F</url>
    <content type="text"><![CDATA[最大流问题最大流问题是算法竞赛中经常考察的问题，其目标是解决这样一类问题：给定源点$s$和汇点$t$，给定包含源点汇点的网络，网络中每条边有其相应的所能经过的最大流量，求源点至汇点最多能有多少流量。用数学语言描述为： 给定有向图$G(V,E)$ $V$表示点集 $E$表示边集，其中每条单向边由三元组组成，$(from,to,cap)\in E$。表示起点、终点、每条边的容量。 给定源点$s$，汇点$t$，求$s$到$t$的最大流量$MaxFlow(s,t)$ 目前已经有相对较为快速的算法（EdmondKarp算法，Dinic算法）而其难点主要在于如何构建网络模型。相对常见的问题主要分为几类： 最小点/边独立集 最小点/边覆盖集 最小割问题 拆点建图 本文将介绍Ford-Fulkerson方法，EdmondKarp算法和Dinic算法。 Ford-Fulkerson方法Ford-Fulkerson算法是最早提出来的用于解决最大流问题的方法，之所以称为方法，是因为它并不严谨，它仅仅是一颗seed，它发展壮大形成了很多有趣的算法，许多科研前辈为了培养这颗seed，花费了毕生精力。其思想十分简单，每次在残余网络中寻找从源点$s$到$t$的增广路，若存在，那我们就从中任取一条，之后答案添加相应的流量，同时添加反向边再形成残余网络，若不存在，那么算法结束，我们已经得到了最大流。 什么是残余网络我们举个例子来说： 上面的这个图，其中边上的参数$a/b$表示：目前通过流量和该边的流量最大限制。由图可知，我们可以得到这两种调度方案。第一种方案的所能运输的最大流量为1，而第二种方案所能运输的最大流量为2。这个问题就很尴尬了，对于给定的图，我们怎么确保算法可以得到最优解呢？这个时候残余网络的出现给了我们一个可靠的解决方案。对于第一个图，我们选则之后，相应的添加反向边，得到下面的图： 我们可以在选择了这条路径之后，可以添加红色的反向边得到残余网络，之后在残余网络中再寻找增广路，仍然可以得到最大流为2。 所谓残余网络其实就是在中途建立退货边，让算法有一个反悔的机会，这真是一个很好的思想！很多时候这个思想可以帮助我们解决很多问题。 时间复杂度分析Ford-Fulkerson方法确实很妙，但是它的时间复杂度分析就不忍直视了，我们假设每次考虑最坏情况，首先花$O(E)$的时间BFS得到所有$s-t$的增广路，但是不巧每次挑选的增广路径的流量都为1。那么，算法的时间复杂度就为$O(FE)$，其中$F$为最大流量。当然这个时间复杂度很高，但是它跑起来还是很快的，因为实际生活中几乎是碰不到这样的图的，相对而言，这个方法还是可以用的。 Ford-Fulkerson的扩展对于Ford-Fulkerson方法的改进主要有两种。 每次找一个$s-t$流量最大的增广路 每次找一个$s-t$距离最短的增广路 对于每次找一个流量最大的增广路，想法就很简单了，就是为了更快的结束算法，但是完成这个目的太慢了。我们考虑一个更简单的问题，每次找一个尽量大的增广路，为了完成这个目标，我们仅仅只需要套一个二分就行了。 对于每次找一个最短的增广路，产生了很多分支，接下来我们介绍EdmondsKarp算法和Dinic算法，同时也解决了最小费用最大流的问题。 EdmondsKarp算法该算法是1972年提出的，它的效率比1970年提出的Dinic算法要差，而这个算法也是Dinic玩剩下的东西，但是为什么paper还是能发出来呢？这真是一个有意思的问题。当时美国和苏联冷战，科研成果并不互通，美国人还不知道Dinic那精妙的思想。 EdmondsKarp算法改善了Ford-Fulkerson中在残余网络中挑选增广路的过程，EdmondsKarp遵循的原则是每次挑选$s- t$最短的增广路，正确性是显而易见的。通过这样的改进，算法的复杂度从$O(FE)$降低到了$O(VE^2)$。 时间复杂度分析这个时间复杂度的分析其实就是Dinic算法的精髓所在，为了解释这个时间复杂度，我们引入分层网络这个概念。 分层网络我们举个例子来说： 左边是我们当前的残余网络，中间的图表示的就是从源点$s$到$t$中经过的分层后的形状。其中相同颜色的节点表示的是到$s$的距离相同，也就是节点的深度$d$相同，由于我们每次找的是$s - t$的最短路这样的话，我们每次最优的增广路肯定是不含相同颜色的，因为若含相同颜色，肯定不是最短的路径了。同样的，最右边的图表示去掉与$t$相同颜色的点，同时将不同层的边补齐，同时也想想为什么相同层不补齐呢？。 现在我们考虑这样一个情况。 我们找到了一条$s - t$的增广路，但是限制最紧的边为$u-v$这条边，那么我们在建立完反向边之后，$v$在分层图中肯定是向后延伸或者不变的，于是我们得到$d_{f’}(v)&gt;=d_f(v)$。但是如果红色的边想再次做限制最紧的点的话，$v$的层次肯定比$u$的层次低一级，于是当这条边再做限制最紧的边时，必然满足$d_{f’’’}(u)&gt;=d_f(u)+2$,$d_{f’’’}(v)&gt;=d_f(v)+2$。等于说，完成这样的一次交换，$u$和$v$的层次都向后延伸了2。由于层次大于等于汇点$t$的层次的话，这个点肯定就不在最短路上了，同时$t$的层次最大就是$V$。那么前面的操作最多只有$\frac V 2$次。相当于每条边最多只有$\frac V 2$次机会做限制最紧的边。 时间复杂度的计算那么对于每条边而言，这一部分的时间复杂度为$O(\frac V 2 E)$。同时我们每次BFS找最短路的时间复杂度为$O(E)$。那么总的时间复杂度就是$O(VE^2)$。通过上面的分析，实际上这个复杂度也是虚高的，通常不需要跑这么久，而且对于某些图跑的比Dinic还要快，但是为什么会快一些呢？如果后面你的Dinic你真正理解的话就再回头想想为什么。 Dinic算法这个算法是真的牛逼，因为EdmondKarp算法其实是Dinic的副产物。通过上面的介绍，我们可以知道，EK算法每次BFS得到最短路径，之后计算的结果就抛弃了，马上构建反向边，在残余网络中重新计算。但是实际上，我们可以利用之前的结果，我们可以通过一次BFS得到每个节点的深度，之后补上相邻层的边之后得到一个分层网络。我们通过上面的分析，$s - t$的增广路的最短路的长度肯定是每次肯定是非递减的！虽然直观上也是这样，那么这也就意味着，我们构建一次分层网络，可以直接把当前分层网络的最短路全部构建反向边，因为不这样做，下次我们找到的最短路还是这些增广路，因为它们已经是最短的了！！！(仔细想想和Dijkstra算法的思想有共同之处啊)我们通过这样做，简单来说我们一次BFS的结果找到了多条路径。 再次看看这个图，我们构建了一次分层网络，可以一次性找到3条增广路呢，我们依次构建反向边即可。要注意每次边权都要更新。 时间复杂度分析按照Dinic的思想，我们每次构建分层网络的时间是边数$O(E)$，每次我们对最短路建反向边只需要对每个节点遍历一边即可$O(V)$，由于每次这样操作一次后，$t$的深度，也就是$d_t$至少会向后延伸1，也就是说$d’_t&gt;=d_t+1$。同样的道理，深度最多是一条链，那么$d_t$最多增长$V$次。所以总时间就是$O(V^2E)$。而这个复杂度确实是相对比较满的，我们的确可以构造出来这样的图，让Dinic跑满，当然Dinic有弧优化技巧尽量避免这些情况，当然这都是后话了，本文暂不做讨论。 代码实现最大流入门题目，HDU-3549，以下是EK和Dinic的代码实现。 EdmondsKarp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 5000;struct Edge&#123; int from, to, cap, flow; Edge(int u, int v, int c, int f):from(u), to(v), cap(c), flow(f) &#123;&#125;&#125;;struct EdmondsKarp&#123; int n, m; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int a[maxn]; int p[maxn]; void init(int n) &#123; for (int i=0; i&lt;n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap) &#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; int Maxflow(int s, int t) &#123; int flow = 0; for (;;) &#123; memset(a, 0, sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = INF; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i=0; i&lt;G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap-e.flow); Q.push(e.to); &#125; &#125; if (a[t]) break; &#125; if (!a[t]) break; for (int u=t; u!=s; u=edges[p[u]].from) &#123; edges[p[u]].flow += a[t]; edges[p[u]^1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow; &#125;&#125;EK;int main(void)&#123; int T,i,j,f,t,c,ca=1,n,m; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;m); EK.init(maxn); for(i=0;i&lt;m;i++)&#123; scanf("%d %d %d",&amp;f,&amp;t,&amp;c); EK.AddEdge(f,t,c); &#125; printf("Case %d: %d\n",ca++,EK.Maxflow(1,n)); &#125;&#125; Dinic123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;const int maxn = 50000;struct Edge&#123; int from, to, cap, flow; Edge(int u, int v, int c, int f):from(u), to(v), cap(c), flow(f) &#123;&#125;&#125;;struct Dinic&#123; int n, m, s, t; vector&lt;Edge&gt; edges; vector&lt;int&gt; G[maxn]; int d[maxn]; bool vis[maxn]; int cur[maxn]; void init(int n) &#123; for (int i=0; i&lt;n; i++) G[i].clear(); edges.clear(); &#125; void AddEdge(int from, int to, int cap) &#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); m = edges.size(); G[from].push_back(m-2); G[to].push_back(m-1); &#125; bool BFS() &#123; memset(vis, false, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); for (int i=0; i&lt;G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap&gt;e.flow) &#123; vis[e.to] = 1; d[e.to] = d[x]+1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int x, int a) &#123; if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i=cur[x]; i&lt;G[x].size(); i++) &#123; Edge&amp; e = edges[G[x][i]]; if (d[x]+1==d[e.to] &amp;&amp; (f=DFS(e.to, min(a, e.cap-e.flow)))&gt;0) &#123; e.flow += f; edges[G[x][i]^1].flow -= f; flow += f; a -= f; if (a == 0) break; &#125; &#125; return flow; &#125; int Maxflow(int s, int t) &#123; this-&gt;s = s; this-&gt;t = t; int flow = 0; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;DN;int main(void)&#123; int T,i,j,f,t,c,ca=1,n,m; scanf("%d",&amp;T); while(T--)&#123; scanf("%d %d",&amp;n,&amp;m);//点数，边数 DN.init(maxn);//初始化邻接表 for(i=0;i&lt;m;i++)&#123; scanf("%d %d %d",&amp;f,&amp;t,&amp;c); DN.AddEdge(f,t,c); &#125; printf("Case %d: %d\n",ca++,DN.Maxflow(1,n));//表示源点是1，汇点是n &#125;&#125; 参考资料国科大-算法设计-卜东波]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>MaxFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈QuickSort]]></title>
    <url>%2FQuickSort%2F</url>
    <content type="text"><![CDATA[快速排序快速排序作为目前我们使用的最常用的排序方式，快速排序平均复杂度的级别和大多数排序都一样为$O(n\log n)​$，但是他的常数相对较小，同时思想也是更加简单，实现过程中也不需要其他的数组进行辅助排序。无论是时间上还是空间上都可以做到极致。但是它的各个细节你真的知道吗？ 原始快速排序在我们初次接触快速排序的时候，我们通常选择给定待排序数组中的第一个元素作为标准，进行左右划分，从而进行递归。下面给出一份基于该思想的代码： 1234567891011121314151617181920212223void QuickSort(int a[],int L,int R)&#123; if(L&gt;=R) return ; if((L+1)==R)&#123; if(a[L]&gt;a[R]) swap(a[L],a[R]); return ; &#125; int m=L,l=L+1,r=R; while(l&lt;r)&#123; while(a[l]&lt;=a[m]&amp;&amp;(l&lt;R)) l++; if(a[l]&lt;=a[m]) l++; while(a[r]&gt;=a[m]&amp;&amp;(r&gt;L)) r--; if(l&gt;r)&#123; swap(a[m],a[l-1]); m=l-1; break; &#125; else &#123; swap(a[l],a[r]); &#125; &#125; QuickSort(a,L,m-1); QuickSort(a,m+1,R);&#125; 可以看到我们每次都是选择待排序数组的第一个作为标准，进行左右划分的。虽然在部分情况下很好用，但是当数据不配合我们的时候，我们就要承担一定风险，例如当传过来的数组$a$原本就是增序的情况下，这份代码就会出现最糟糕的情况，这时算法需要迭代$n$轮，由于每轮的复杂度都是$O(n)$，那么相应的时间复杂度就变成了$O(n^2)$了。 下面我们讨论的就是快速排序的各种优化方法。 随机快速排序这种想法就非常直接了，听说你想造数据搞我，那我就打乱你的数据，我们为了保证数据和正常情况下的平均复杂度一样，我们最开始就不要选择第一个元素了，我们在L,R当中随机选一个，这样的话，我们几乎可以保证算法发生最坏情况是不可能的，所以通常情况下我们使用下面这一份代码就足够了： 123456789101112131415161718192021222324void RandomQuickSort(int a[],int L,int R)&#123; if(L&gt;=R) return ; if((L+1)==R)&#123; if(a[L]&gt;a[R]) swap(a[L],a[R]); return ; &#125; int m=L,l=L+1,r=R,x=rand()%(R-L+1); swap(a[L],a[x+L]); while(l&lt;r)&#123; while(a[l]&lt;=a[m]&amp;&amp;(l&lt;R)) l++; if(a[l]&lt;=a[m]) l++; while(a[r]&gt;=a[m]&amp;&amp;(r&gt;L)) r--; if(l&gt;r)&#123; swap(a[m],a[l-1]); m=l-1; break; &#125; else &#123; swap(a[l],a[r]); &#125; &#125; RandomQuickSort(a,L,m-1); RandomQuickSort(a,m+1,R);&#125; 可以看到我们就是新申请了一个变量$x$，存一下应该和哪个元素作为标准即可。 但是这种优化仅仅只是开始，有很多人提出了非常有意思的并且有效的想法。 中位数快速排序这个人呢，他就想啊，我们排序的时候为什么不首先找到中位数，之后使用中位数做标准呢？这样不是很简单的就能保证算法每次都从中间划分吗?于是这个人在随机化取下标的地方做了一些修改，其实也就是借用了利用快速排序找出第k大数的思想，这个的平均时间复杂度也是O(n)，于是这个人在QuickSort中，又套了一层QucikSort。代码的框架如下： 123456789101112131415161718192021222324252627int Find_Median_ID(int a[],int L,int R,int k)&#123;&#125;void MedianQuickSort(int a[],int L,int R)&#123; if(L&gt;=R) return ; if((L+1)==R)&#123; if(a[L]&gt;a[R]) swap(a[L],a[R]); return ; &#125; int m=L,l=L+1,r=R,x=Find_Median_ID(a,L,R,(R+L)/2); swap(a[L],a[x+L]); while(l&lt;r)&#123; while(a[l]&lt;=a[m]&amp;&amp;(l&lt;R)) l++; if(a[l]&lt;=a[m]) l++; while(a[r]&gt;=a[m]&amp;&amp;(r&gt;L)) r--; if(l&gt;r)&#123; swap(a[m],a[l-1]); m=l-1; break; &#125; else &#123; swap(a[l],a[r]); &#125; &#125; MedianQuickSort(a,L,m-1); MedianQuickSort(a,m+1,R);&#125; 从这开始，其他的思想又出现了，到此位置，以上的快速排序的理论的最坏复杂度依然为$O(n^2)$。没有真正做到$O(n\log n)$级别。 中位数的中位数快速排序-BFPRT这个人在前者的思想上又做了一些改变，想法也是很直接，既然你找中位数这么麻烦，我就要求松一点，我不找最好的中位数，我找一个接近中位数的数。于是提出了中位数的中位数这么一个有意思的东西，算法也是十分直接的，其方法是：我们每次把原数组分为按5分组，对每一组中的5个数我们使用插入、选择、堆排等排序方式进行排序，挑出每组的中位数，每次把挑出来的每组的中位数放到当前数组前面作为中位数序列。之后我们对该段进行递归排序，返回中位数。之后使用这中位数的中位数作为标准，对原数组左右进行划分。 举个例子： 我们首先把数组按照5进行划分，最后一个长度不足5的我们舍弃不考虑。经过分组之后，我们再对中位数进行排序，返回中位数的中位数大小。通过这种方式我们还真的得到了一个理论最坏情况下是$O(n\log n)$的排序算法，虽然这个算法常数较大，实际跑起来的时候可能并不如前面的算法，但是这并不影响这个算法的价值。 代码如下： 123456789101112131415161718192021222324252627282930313233343536int BFPRT(int a[],int L,int R)&#123; int i,cnt=L; if((R-L+1)&lt;5)&#123; sort(a+L,a+R+1); return a[(R+L+1)/2]; &#125; for(i=L;i&lt;R;i+=5)&#123; sort(a+i,a+i+5); swap(a[cnt],a[i+2]); cnt++; &#125; int Median=BFPRT(a,0,cnt-1); for(i=L;i&lt;R;i++)&#123; if(a[i]==Median)&#123; swap(a[L],a[i]); break; &#125; &#125; int l=L+1,m=L,r=R; while(l&lt;r)&#123; while(a[l]&lt;=a[m]&amp;&amp;(l&lt;R)) l++; if(a[l]&lt;=a[m]) l++; while(a[r]&gt;=a[m]&amp;&amp;(r&gt;L)) r--; if(l&gt;r)&#123; swap(a[m],a[l-1]); m=l-1; break; &#125; else &#123; swap(a[l],a[r]); &#125; &#125; BFPRT(a,L,m-1); BFPRT(a,m+1,R); return a[(R-L+1)/2];&#125; 代码写的很丑，但是勉强能看看，也许会有BUG 延迟中位数快速排序由于BFPRT的选择过程实在太麻烦了，于是有人在想，你这个中位数的中位数算来算去不就是一个接近中位数的数吗？那我何必这么麻烦，我们不如随机的选，只不过我选的时候计算一下，如果当前的数在$\lfloor \frac n 4 \rfloor$到$\lfloor \frac {3n} 4 \rfloor$之间，那么我就用这些数来作为标准。由于这些数有$\frac n 2$个，每次选就相当于我们抛硬币，那么期望次数就是2次。这样的话，就算我们每次选到了边缘，也没有关系。我们最坏我们的算法也会在$O(n\log_{\frac 4 3} n)$这个限制下。这真的是一个很有意思很精髓的想法。 代码如下： 12345678910111213141516171819202122232425262728293031323334void LazyRandomQuickSort(int a[],int L,int R)&#123; if(L&gt;=R) return ; if((L+1)==R)&#123; if(a[L]&gt;a[R]) swap(a[L],a[R]); return ; &#125; int m=L,l=L+1,r=R,x,cnt; while(true)&#123; x=rand()%(R-L+1); cnt=0; for(int i=L;i&lt;=R;i++)&#123; if(a[i]&lt;=a[L+x]) cnt++; &#125; if((cnt&gt;=(R-L+1)/4)&amp;&amp;(cnt&lt;=(3*(R-L+1))/4))&#123; break; &#125; &#125; swap(a[L],a[x+L]); while(l&lt;r)&#123; while(a[l]&lt;=a[m]&amp;&amp;(l&lt;R)) l++; if(a[l]&lt;=a[m]) l++; while(a[r]&gt;=a[m]&amp;&amp;(r&gt;L)) r--; if(l&gt;r)&#123; swap(a[m],a[l-1]); m=l-1; break; &#125; else &#123; swap(a[l],a[r]); &#125; &#125; LazyRandomQuickSort(a,L,m-1); LazyRandomQuickSort(a,m+1,R);&#125; 去重复数字的快速排序我们在写快速排序的时候，其实很多时候都浪费了计算资源，比如说我们之前我们每次进行子问题递归的时候，区间都是$L,m-1$和$m+1,R$但是我们这样做的话，对于大量的重复数字出现的情况下，通常会浪费计算资源。但是这种情况我们原本是可以避免的，而实现的想法也十分简单。简单来说：我们每次在调整的过程中我们希望与标准相同的数集中起来，之后递归的时候再精简一下区间即可，这个改进的的确确是非常非常有用的。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void BoundQuickSort(int a[],int L,int R)&#123; if(L&gt;=R) return ; if((L+1)==R)&#123; if(a[L]&gt;a[R]) swap(a[L],a[R]); return ; &#125; int m=L,l=L+1,r=R,BoundL,BoundR; while(l&lt;r)&#123; while(a[l]&lt;=a[m]&amp;&amp;(l&lt;R)) l++; if(a[l]&lt;=a[m]) l++; while(a[r]&gt;=a[m]&amp;&amp;(r&gt;L)) r--; if(l&gt;r)&#123; swap(a[m],a[l-1]); m=l-1; break; &#125; else &#123; swap(a[l],a[r]); &#125; &#125; BoundL=m-1; BoundR=m+1; l=L,r=R; while(true)&#123; while(a[l]!=a[m]&amp;&amp;(l&lt;BoundL)) l++; if(a[l]!=a[m]) l++; while(a[BoundL]==a[m]&amp;&amp;(BoundL&gt;L)) BoundL--; if(l&gt;=BoundL)&#123; break; &#125; else &#123; swap(a[l],a[BoundL]); &#125; &#125; while(true)&#123; while(a[BoundR]==a[m]&amp;&amp;(BoundR&lt;R)) BoundR++; if(a[BoundR]==a[m]) BoundR++; while(a[r]!=a[m]&amp;&amp;(BoundR&lt;r)) r--; if(r&lt;=BoundR)&#123; break; &#125; else &#123; swap(a[r],a[BoundR]); &#125; &#125; BoundQuickSort(a,L,BoundL); BoundQuickSort(a,BoundR,R);&#125; 总结虽然快速排序已经是多年前的算法，但是其思想仍然值得我们仔细思考，细细品味。 参考资料国科大-算法设计-卜东波]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>QuickSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binomial堆]]></title>
    <url>%2FBinomial%2F</url>
    <content type="text"><![CDATA[Binomial 堆是什么？首先我们知道Binomial这个单词的意思是二项式，但是为什么取个名字呢？也许读完本文你就明白了。 二叉堆首先我们回顾一下二叉堆，对于节点数为$n$的它，具有下面几个基本性质 树高$\lceil \log n \rceil$ 插入节点时间复杂度$O(\log n)$ 访问根节点(优先级最高的节点)时间复杂度$O(1)$ 删除根节点时间复杂度$O(\log n)$ 合并两棵树时间复杂度： 自底向上合并时间复杂度为$O(n)$ 自顶向下合并时间复杂度为$O(n\log n)$ 虽然说二叉堆具有查找上极其优良的性质，但是在合并的时候（虽然一般情况下用不到合并这个操作），时间复杂度却没有达到$O(\log n)$级别。这就使得有些人在想，我们可不可以放松一下访问根节点的时间到$O(\log n)$，但是加速合并两棵树呢？于是Binomial 堆就被提出来了，同时比预想的更加强大！ 思想由于我们要加速合并，那么肯定是有好几棵树同时存在才需要合并，所以Binomial 堆的本质思想就与二叉堆有很大不同。Binomial 堆是由森林构成的，而二叉堆是一棵树。所以这也导致了合并这个需求在Binomial 堆中是如此的重要。 但是Binomial 又是什么意思呢？直观上我们只知道Binomial 表示$2^0,2^1,2^2,…,2^n$这样的数目。但是这和森林有什么关系呢？实际上这恰恰是Binomial 堆的精髓所在，它表示的是森林中每棵树的节点数为$2^k$这么多，同时我们也称当前这棵树为$B_k$。本文中介绍小根Binomial 堆，如果不懂什么是小根，那么请移步我的另一篇文章。 Binomial 堆简单的例子，表示的是0阶，1阶，2阶，3阶，4阶，5阶树的结构： 一般的结构形式： 注意: 通过上面的描述，我们可以对每棵数得到几个很明显的性质： $|B_k|=2^k$ $height(B_k)=k$ $degree(B_k)=k$ 对于一棵树的每一个节点来说，其第$i$个儿子的度为$i-1$ 对于总节点为$n$的Binomial 堆而言，其具有以下几个性质： 最多有$\lfloor \log n \rfloor +1$棵树，很明显，其实就是n在二进制下有多少个1就有多少棵数 树高最高为$\log n$，因为二进制下最高位一定为$\log n$位 也许这里会有疑惑，但是请务必仔细想想为什么会有这种性质。 合并条件-Union我们规定Binomial 堆中不允许出现结构相同的两棵数，换句话说，假如森林中出现了阶数相同的两棵树，我们需要进行合并。我们合并的方式也很简单，将根节点的值更大的树作为儿子连上根节点的值更小的树。 一个简单的例子： 请注意这是一个递归过程。我们每次合并之后都需要再检查，其实这里本质上就是二进制的进位操作。由于最坏的情况下我们需要进位$\log n$次，所以这一步的复杂度最坏为$O(\log n)$。但是这一步均摊下来其实是很快的，因为其实二进制的进位操作并不会每次都是最坏情况，而且也不可能出每次都是最坏情况，这一步经过证明我不会，平均的时间复杂度为$O(1)$。 插入节点-Insert我们在插入一个节点的时候，想法也是非常简单的，我们首先将其视为$B_0$（也就是单个节点的树），并将其加入到森林中，之后我们使用上一步讲到的合并条件，该步复杂度与合并条件相同,时间复杂度为$O(1)$。 提取最小值-Top提取最小值，我们采用最简单的方法，对森林中每棵树的根节点进行一次遍历，找到根最小的节点的值返回即可。由于最多有$\lfloor \log n \rfloor +1$棵树，故时间复杂度为$O(\log n)​$。 删除最小值-Pop首先我们通过上一步的方法，定位到最小值点在森林的哪一个树中，之后我们将根节点移除，那么此时它应该分裂成了一些更小的树，由于$B_k$这样的一棵树可以分裂为$B_0,B_1,B_2,…,B_{k-1}$这样的一些子树，由于$k$最大为$\log n$,故我们最多插入$\log n$次，每次插入的时间为$O(1)$，故该步的时间复杂度为$O(\log n+\log n)=O(\log n)$。 对比 二叉树 Binomial Union O(n) O(1) Insert O(log n) O(1) Top O(1) O(log n) Pop O(log n) O(log n) 参考资料国科大-算法设计-卜东波]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉堆]]></title>
    <url>%2FPQueue%2F</url>
    <content type="text"><![CDATA[什么是二叉堆？二叉堆是什么呢？我的理解是堆是一个数据结构，为了满足我们的需求所精心设计的数据结构。而二叉堆正是为了满足我们的需求而被提出来的，同时它也叫做优先队列，它所能实现的最重要的功能是： 在$n$个元素中通过$\log n$时间找到优先级最大/最小的元素 我们传统的方式是遍历数组去寻找，这样需要花费$n$级别的时间，那么对于大量查询优先级最大/最小的元素情况下，我们使用二叉堆进行优化可以直接把复杂度的级别下降。 大根堆/小根堆大根堆和小根堆是我们最常用的二叉堆的结构，相应的，它们是为了满足每次查询优先级最大/最小的元素而分别设计的。它们的本质思想都一样，故在本文中我们会详细介绍小根堆，同时本文中的元素定义为int类型的数值。 结构 小根堆是一颗完全二叉树，请注意这一点，因为这一步保证了我们每次查询的复杂度为$\log n$ 小根堆的父亲节点的数值都小于其儿子节点 例如： 这就是一个典型的小根堆，而其右边的就是其使用数组存储的方式，为了简单，我们通常使用数组版本的，当然指针版本的更加优越，但是本文都是基于数组实现的。 注意： 这里有个很简单的技巧，对于每个节点号为$id$的节点而言，其左儿子是$2id$，右儿子是$2id+1$ 同时对于节点号为$id$的，其父亲节点编号为$id/2$ 我们所需要完善的几个函数对于一个堆，我们只需要满足三个函数即可 节点的插入Insert(int x) 根节点的访问Top() 根节点的删除Pop() 但是其实有难度的只有第一个和第三个功能。 请关注为什么函数的名字为什么与队列函数类似。 Insert()我们进行插入操作很简单，简单来说只有两步，假如我们需要插入$x$： 首先将$x$放置在数组的最后，这一步保证了插入之后仍然是一棵完全二叉树 向上调整$x$的位置，倘若比其父亲小的话，进行交换，直到无法再进行调整。 一个例子： 左边是首先插入到最后一个位置，之后向上调整到合适的位置。显然，我们插入最多向上交换$\log n$次，故复杂度为$O(\log n)$ Top()根节点的访问就很简单了，只要访问数组的第一个位置就行了。故复杂度为$O(1)$ Pop()我们进行根节点的删除操作也很简单，简单来说，只需要三步： 将根节点的值和最后一个节点的值交换 删除最后一个节点 调整根节点的位置，每次和最小的儿子进行交换，直到无法进行交换。 请特别注意第三个步骤，并好好想想为什么一定要这样做。 一个例子： 首先和最后一个节点进行交换，之后删除，最后调整根节点的位置。由于交换后的节点最多也是向下交换$\log n$次，故复杂度为$O(\log n)$ 小根堆的代码实现，数组版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;int heap[1000005],size=0;void Insert(int x)&#123; int fatherid,now; size++; heap[size]=x; now=size; while(now&gt;1)&#123; fatherid=now/2; if(heap[fatherid]&gt;heap[now])&#123; swap(heap[fatherid],heap[now]); now=fatherid; &#125; else break; &#125;&#125;int Top()&#123; if(size) return heap[1]; else printf("NO element, can't get top\n"); return -1;&#125;void Pop()&#123; int leftsonid,rightsonid,now; if(size)&#123; swap(heap[1],heap[size]); size--; now=1; while(now&lt;=size)&#123; leftsonid=now*2; rightsonid=now*2+1; if(leftsonid&lt;=size&amp;&amp;rightsonid&lt;=size)&#123; if(heap[leftsonid]&lt;heap[rightsonid])&#123; if(heap[leftsonid]&lt;heap[now])&#123; swap(heap[leftsonid],heap[now]); now=leftsonid; &#125; else break; &#125; else &#123; if(heap[rightsonid]&lt;heap[now])&#123; swap(heap[rightsonid],heap[now]); now=rightsonid; &#125; else break; &#125; &#125; else if(leftsonid&lt;=size)&#123; if(heap[leftsonid]&lt;heap[now])&#123; swap(heap[leftsonid],heap[now]); now=leftsonid; &#125; else break; &#125; else &#123; break; &#125; &#125; &#125; else printf("NO element, can't pop\n");&#125;int main(void)&#123; int i,j,n,m; n=100; for(i=0;i&lt;n;i++)&#123; Insert(rand()); &#125; while(size)&#123; printf("%d\n",Top()); Pop(); &#125;&#125; 参考资料国科大-算法设计-卜东波]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF1091E-New Year and the Acquaintance Estimation]]></title>
    <url>%2FCF1091E%2F</url>
    <content type="text"><![CDATA[题目大意给我们$n$个点的度数$a_1,a_2,…,a_n$,同时还有一个点的度$x$尚未确定。我们希望$a_1,a_2,…,a_n,x$构成的点度序列能够形成一个简单图，所谓简单图就是无自环，重边的无向图，连通性无需保证。要求从小到大输出$x$的所有可能解。若没有任何解输出$-1$。 基本知识 Havel–Hakimi algorithm 给定一个点度序列$a_1,a_2,…,a_n$能够形成一个简单图的充要条件是: a_2-1,a_3-1,...,a_{a_1+1}-1,a+{a_1+2},..,a_n构成一个简单图。即我们可以根据这个进行递归。 人话解释：每次拿一个点度最大的$a_1$出来，将剩余的前$a_1$个点度减一即可。注意，这里每次都是要排序的。故递归求解的话时间复杂度是$n^2logn$的 Erdős–Gallai theorem 给定一个点度序列$a_1,a_2,…,a_n$能够形成一个简单图的充要条件是: \sum_{i-1}^ka_i]]></content>
      <categories>
        <category>codeforces</category>
      </categories>
      <tags>
        <tag>graph-theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐马尔可夫模型详述]]></title>
    <url>%2FHMM%2F</url>
    <content type="text"><![CDATA[什么是隐马尔可夫模型？隐马尔可夫模型实际上是一个双重的随机过程，我们不知道具体的状态序列，只知道转移的概率，即模型的状态转移过程是未知的，而观察事件的随机过程是状态转换过程的随机函数，即我们希望通过可见的事件变换去预测深藏在其背后的本质规律。 请记住上述提到的几个概念： 状态序列(这是我们需要去预测的) 观察序列(这是我们已知的) 状态序列的转移概率(这是我们已知的) 状态序列对观察序列的转移(这是我们已知的) 隐马尔可夫链成立的三个假设（当然可以不需要理解） 状态构成一个隐马尔可夫链 P(q_i|q_{i-1}q_{i-2}...q_1)=P(q_i|q_{i-1}) 不动性假设（状态与具体时间无关） P(q_{i+1}|q_i)=P(q_{j+1}|q_j) 输出独立性假设 P(o_1..o_i|q_1...q_i)=\prod_tP(o_t|q_t) 其实这里的隐马尔可夫链中的链就表示假设了是一阶的！我们假设满足上面的性质。 现在我们考虑一个场景假如我们面对一堆过去的数据，过去的数据当中只有自然生长下的海藻的每天的状态。 我们也有一些最近的数据，最近的数据中有海藻的状态和每天的天气情况。 现在我们给定天气的转移矩阵，天气对海藻状态影响的矩阵。我们希望根据这些数据，去预测过去的天气。 海藻的状态只有4种： 干 稍干 潮湿 湿润 天气的状态只有3种： 晴 阴 雨 天气状态转移矩阵（后面简称为A）： 雨 阴 晴 雨 0.625 0.125 0.25 阴 0.375 0.25 0.375 晴 0.25 0.25 0.5 注意：上表表示的是今天的天气分别是雨，阴，晴的情况下，明天的天气是雨，阴，晴的概率分布。 天气对海藻干湿的影响(后面简称为B): 干 稍干 潮湿 湿润 晴 0.60 0.20 0.15 0.05 阴 0.25 0.25 0.25 0.25 雨 0.05 0.10 0.35 0.50 注意：上表表示的是今天的天气分别是雨，阴，晴的情况下，今天的海藻出现干，稍干，潮湿，湿润的概率分布。 建立模型我们的任务是根据观察序列去推测状态序列。 首先我们根据之前的信息：构建状态集合$s$，状态转移矩阵$A$，初始状态概率分布$\pi$，观察集合$ss$，状态对观测的影响矩阵$B$ 对于我们这个题目而言，状态集合$s$为(晴，阴，雨)，观察集合$ss$为(干，稍干，潮湿，湿润)，请务必注意这个地方！ 那么我们可以得到五元组模型:$(s,ss,\pi,A,B)$，通常我们将模型简写为三元组:$\lambda =(\pi,A,B)$。 对于上述三元组，只有$\pi$是未知的，这个东西怎么统计出来呢？其实很简单，由于我们包含最近的数据，我们根据最近的天气可以统计出来每种天气出现的概率，那么这个分布就是$\pi$，公式表示为： \pi_i=P(q_1=s_i)当然这仅仅是对于这个任务是这样计算的，别的任务可能会不一样。上述公式表示的就是说第$i$种情况出现的概率 比如说统计后大概长成这个样子： 晴 雨 阴 P 0.5 0.05 0.45 求解过程我们现在已知观察序列$O=o_1….o_n$，模型$\lambda =(\pi,A,B)$ 。现在我们需要求给定模型与观察序列的情况下求状态序列$Q$。有我们需要以下概率最大： P(O|Q,\lambda )意思也很简单啊，就是我们求这个条件概率，当前模型$\lambda ​$来说，希望找到一个状态序列$Q​$使得观察序列O发生的可能性最大。 我们假设$Q=q_1…q_n$ 我们把上面的式子打开，有： P(O|Q,\lambda )=\pi_{q_1}A_{q_1q_2}A_{q_2q_3}...A_{q_{n-1}q_n}B_{q_1o_1}B_{q_2o_2}...B_{q_no_n}对上面的式子我们很简单的可以想到枚举每一种$Q$，对每一种都进行计算，之后输出使得$P(O|Q,\lambda )$最大的那个$Q$就可以了。但是这当然是不可以的，因为这个是指级别的，$n$大的话这个方法就凉了。 解释一下上面的公式： $\pi_{q_1}$表示最初天气为$q_1$成立的概率 $A_{ij}​$表示天气从$i​$到$j​$转移的概率 $B_{ij}$表示天气为$i$的情况下海藻状态为$j$的概率，也叫发射概率 viterbi算法维特比算法分为前向后向，但是我感觉会一种就行了，其实都是一样的。这里介绍一下前向算法。 前向算法思想：假设我们已知了对于$o_1…o_{n-1}o_n$最优的状态序列肯定是$o_1…o_{n-1}$的一个序列转移过来的，等于说我们对当前的一层计算来说，对于每个节点只需要考虑前面一层的结果就可以了。即有 dp_{iq_i}=\max_{k\in s} dp_{(i-1)k}A_{k(q_j)}B_{q_jo_i}$dp$表示计算的结果，$q_i$表示当前层的状态，$k$表示枚举前一层的状态，从观察状态集合中枚举。$max$表示存储后面式子的最大值。 算法流程： C++的代码，写起来很简单，每种语言都可以按照这个方式写。但是为了保证精度，我们一般是取$log$的，这份代码的结果应该会很差！ 123456789101112131415161718192021void viterbi(int O[],double PI[],double A[][],double B[][])&#123;//传观察序列和模型 int i,j,back; int path[][]； double dp[][],MX； for(i=1;i&lt;=n;i++)&#123;//初始化 dp[1][i]=PI[i]; &#125; for(i=1;i&lt;=m;i++)&#123; for(j=1;j&lt;=n;j++)&#123; MX=-1; for(k=1;k&lt;=n;k++)&#123;//枚举前一层 if(MX&lt;dp[i-1][k]*A[k][j])&#123; MX=dp[i-1][k]*A[k][j];//找到最大的 back=k; &#125; &#125; path[i][j]=back;//用于回溯 dp[i][j]=MX*B[j][O[i]];//计算结果存起来 &#125; &#125;&#125; 一个简单例子为了结果看起来比较正常，我们把初始分布$\pi$ 设的极端一点，同时我们再次召唤之前的表。 晴 阴 雨 P 1 0 0 天气状态转移矩阵$A$： 雨 阴 晴 雨 0.625 0.125 0.25 阴 0.375 0.25 0.375 晴 0.25 0.25 0.5 天气对海藻干湿的影响$B$: 干 稍干 潮湿 湿润 晴 0.60 0.20 0.15 0.05 阴 0.25 0.25 0.25 0.25 雨 0.05 0.10 0.35 0.50 对于我们给定的观测序列：干，潮湿，湿润。我们计算的结果入上图所示。其中红色括号的结果就是表示结果是上一次的第几个节点过来的。 到此为止，隐马尔可夫模型的这个例子就介绍完了，当然问题有其他变种，一般是在viterbi算法上动刀，不会解决的话可以留言评论。 A和B矩阵怎么求？我们大部分时候，其实只有训练数据和测试数据，没有这些转移矩阵，这个时候我们可以通过最大似然估计来求这些矩阵(看起来吓人)。就好比这一题我没有给出矩阵$A,B$的话怎么办？ 其实我们也可以做出来这个题目，因为我在题目中特意强调了我们还有一些最近的标注数据，这时候我们可以通过最近的数据把矩阵$A,B$给估计出来，做法如下。 其实就是统计一下就行了，对于A矩阵： A_{ij}=\frac {total(i\&j)}{total(i)}人话解释：天气状态为$i$的后面连接了天气状态为$j$的次数除以天气状态为$i$的出现总次数。 对于B矩阵： B_{ij}=\frac {total(i\&j)}{total(i)}人话解释：天气状态为$i$的对应海藻的状态为$j$的次数除以天气状态为$i$的出现的总次数。 我们在求的时候一般加上松弛操作，即 A_{ij}=\frac {total(i\&j)+1}{total(i)+1} B_{ij}=\frac {total(i\&j)+1}{total(i)+1}一个小项目为了使本文有一点实用价值，我把我的代码放在这里。一个序列标注的小东西。 参考资料国科大自然语言处理课件 胡玥]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transformer模型详解]]></title>
    <url>%2FAttention%2F</url>
    <content type="text"><![CDATA[背景目前深度学习中用于做NLP的方法，大多都是首先将句子进行分句，之后将每个单词使用与训练好的词向量进行表示(其实这就是一种迁移学习？)，通过这一步我们把一个句子转化为向量的序列。这样的好处是我们可以把一个句子使用一个向量模型来表示，即每个句子我们都对应一个矩阵$x=(x_1,x_2,…x_n)$其中$x_i$表示第$i$个词的词向量，通常我们记为行向量，假如预训练好的向量维度为$d$,也就是说一个句子我们可以映射为$x\in R^{n*d}$。通过这个操作，我们可以将语言化作向量表示，这是一个很好的建模方式。 我们为了处理这些信息主要分为以下几个思路： RNN 可以很好的获得时序信息 CNN 可以很好的获得全局信息 Attention google提出的全新思想，在各大模型上都有提升 RNN第一个思路是RNN，思想是很简单的，进行递归式的信息提取： y_t=f(y_{t-1},x_t)由于我们在每一步进行计算的时候都需要依赖上一步计算的结果，这导致了RNN无法并行计算，这是这个模型原本就存在的缺陷，但是RNN可以很好的学习到时序信息。相应的，我们很难获取到全局信息，倘若我们想得到全局信息，我们一般使用双向RNN或者双向LSTM。 CNN第二个思路是CNN，思想也是十分简单的，进行窗口式的扫描，对于尺度为3的卷积： y_t=f(x_{t-1},x_t,x_{t+1})由于CNN的每一步进行计算的时候是独立的，故我们可以很方便的进行并行计算。其实通过这一步我们只能获取到局部的信息，但是我们通过堆叠的方式增大感受野，使得模型能够获得很好的全局信息！但是相应的，CNN的时序信息获取效果不如RNN。 AttentionGoogle在2017年的论文Attention is All You Need提供了第三个思路，这个想法也也是十分简单的，一般而言我们记作： y_t=f(q_t,K,V)对于全局过程我们记作： y=f(Q,K,V)其中$Q,K$与$V$相同的时候，我们称作self-attention。计算方式在文章后续会详叙。 Transformer注意力机制 上图看起来十分复杂，我们简化一下。 这其实就是一个Seq2Seq模型，我们左边把一个encoder输入进去，右边就decoder得到输出。由于上图有两个部分，我们不妨将其中的的部分再打开看看： 我们随之而来的问题就是这个encoder是如何把信息传递给右边的呢？因为这个图和上面的压根就不一样好吗？我们再将图片打开拓展: 意思就是说对于每一层的encoder的输出，我们会和decoder的输入进行结合。 我们再取一种的一层做详细展示： 我们可以看到在解码层的做了两次attention，我们在第二次的attention时使用了左边的encoder传递过来的信息。上面这张图我觉得有点小问题，也许是我理解错误。。我认为左边的encoder端上面应该是没有箭头的。 传统Attention 机制定义Attention的翻译过来就是注意力，这表示了人类的偏好，我们在观察一个图片的时候，往往对图像的某一部分有更集中的偏好，就是所谓的”抢镜”。对某一部分有更高的关注度，这使得我们对图片有一个更加准确的感受。 我们拓展到文本中，例如我们在进行翻译任务的时候，翻译当前词的时候一般是对序列的局部信息有偏好，但是对于每个单词而言，对原序列的关注程度肯定是不一样的。attention就是使用最简单的方法实现这个功能。 计算方式我们再次召唤前面的公式: y_t=f(q_t,K,V)我们简述一下这个$f$是如何进行计算的。 我们输入一组$K$与$V$与查询$Q$，首先我们对每个$K_i$与$Q$计算相似度得到$S_i$,之后将$S$通过softmax函数进行归一化得到分布$a$，之后我们计算$a$与$V$的加权和得到对于查询$Q$的attention向量Att-V。 其中对于$f(Q,K_i)$(都为列向量的话)的计算方式主要分为以下几种： 点乘 dot product : $f(Q,K)=Q^TK$ 权重 general : $f(Q,K)=Q^TWK$ 拼接 concat ：$f(Q,K)=W[Q^T;K]$ 神经网络 perceptron ：$f(Q,K)=V^T\tanh (WQ+UK)$ 对于$Q$,$K$与$V$相同的情况下，我们也称作为自注意力机制，希望寻找文本中内在的联系。也就是说，在序列内部做Attention，寻找序列内部的联系。Google论文的主要贡献之一是它表明了内部注意力在机器翻译（甚至是一般的Seq2Seq任务）的序列编码上是相当重要的。 传统模型有一个非常明显的缺点，就是无法获得时序信息，就算我们把顺序打乱，我们算出来的结果一样是不变的，这个就有点不太合理了！当然我们一般使用attention去辅助RNN和CNN，由于RNN和CNN已经包括了时序信息，可能会好一些。 transformer中的Attention机制在transformer当中的Attention机制与传统的attention机制还是有很大区别的。分别叫做 Scaled Dot-Product Attention 和 Multi-Head Attention。 Scaled Dot-Product Attention其结构图如下图所示： 首先第一个问题,$Q,K,V$从哪里来？按照我的理解，对于我们输入的句子$x=(x_1,x_2,…x_n)$，这一步可以是原本的词向量，也可以是对于输入的词向量做线性变化，例如$Q=xW^q,K=xW^k,V=xW^v$，例如： 我们对于input的词向量Thinking Machines，通过三个矩阵$W^q,W^k,W^v$，得到$Q,K,V$,于是我们依次遍历$Q_i$，计算每个的$Q_i$的注意力向量。 首先对于$q_1$,我们采用dot product进行计算相似度$S_i$ 之后我们将$S_i$ 除以$\sqrt{d_k}$其中$d_k$表示$K$的维度，加上这个是为了防止内积太大，如果内积过大，会导致softmax进入饱和区，就没有注意力这个作用了。接下来我们通过softmax计算概率分布。 最后我们计算加权和得到对于$q_1$的注意力向量$z_1$。直以递归下去，我们可以对每个$q$进行相同的操作即可。听上去这一步好像很麻烦，其实我们用矩阵表示的话，就很简单且简约了： 首先输入词向量$X$(行向量)，计算$Q,K,V$ 这一步就更加直观了，但是我们需要好好理解一下$QK^T$ 这一个计算过程，这一步实际上是计算了一个word2word的attention矩阵。例如我们对”I have a dream”计算的话 其中每个格子$grid_{ij}$ 表示的是第$i$个单词和第$j$个单词的相似度，这肯定是一个对称矩阵啦！现在我们回到transformer的结构图当中，可以很明显的看到有的self-attention前面加上了masked，这又是什么意思呢？ 简单来说就是为了防止程序看见未来的信息，而用灰色区域(0.0)覆盖上。 Multi-Head Attention多头的意思就很简单了，就是将工作重复做几次而已。论文中倒是画的很吓人的样子。所谓“多头”（Multi-Head），就是只多做几次同样的事情（参数不共享），然后把结果拼接。 我们重复几次，将得到的$Z$矩阵进行拼接即可 首先我们对输入的$X$进行计算多次 将计算完的结果拼接$Z_0+Z_1+….+Z_n$，之后使用一个线性变换为指定维度的$Z$ 整个的框架如下： Position Embedding然而，我们经过思考之后，可以发现这个计算方式和传统的一样啊，我就算位置变了，对attention的计算结果不变。这个问题就很严重了，很有可能我们在机器翻译的任务当中，我们确实算出来了翻译结果应该包含了哪些单词，但是结果很有是乱序的，那么就没法用了。transformer为了解决这个问题，祭出了Position Embedding这个东西。Google是直接给出了一个公式来构造Position Embedding。 PE_{2i}(p)=\sin(p/10000^{2i/d_{pos}})\\ PE_{2i+1}(p)=\cos(p/10000^{2i/d_{pos}})这里的意思是将position为$p$的位置映射为一个$d_{pos}$维的位置向量，这个向量的第$i$个元素的数值就是$PE_i(p)$。Google在论文中说到他们比较过直接训练出来的位置向量和上述公式计算出来的位置向量，效果是接近的。那么为了减少计算复杂度，我们何必自己再训练呢? 原文中提到采用这个公式的另一个原因的是sin和cos，满足一些良好的性质: \sin(a+b)=\sin(a)\cos(b)-\cos(a)\sin(b) \cos(a+b)=\cos(a)\cos(b)-\sin(a)\sin(b)这使得位置为p+k的向量可能可以使用位置为p的向量线性表出。 PE_{2i}(p+k)=\sin((p+k)/10000^{2i/d_{pos}})= \sin(p/10000^{2i/d_{pos}})\cos(k/10000^{2i/d_{pos}})-\cos(p/10000^{2i/d_{pos}})\sin(k/10000^{2i/d_{pos}})由于$k$是定值，而$\sin(p/10000^{2i/d_{pos}})$和$\cos(p/10000^{2i/d_{pos}})$确实是知道的，所以确实为线性表出提供了可能性吧。。 我们在input输入的时候加入位置信息，同时我们在decoder的输入过程中也加入了位置信息。 Position-wise Feed-forward Networks在进行了Attention操作之后，encoder和decoder中的每一层都包含了一个全连接前向网络，对每个position的向量分别进行相同的操作，包括两个线性变换和一个ReLU激活输出： FFN(x)=max(0,xW_1+b_1)W_2+b_2值得注意的是encoder的每一层的$W_1$和$W_2$都不相同。 The Residuals由于transformer的结构十分复杂，训练的时候很容易出现梯度消失，导致网络难以训练，文章采用的思想借鉴了何恺明的残差网络的思想，在每一次操作之后为了保证损失能够尽量回传，每层的输入会和输出进行叠加。 其中的Add&amp;Normalize就是叠加过程。公式记作： output=LayerNorm(x+Sublayer(x))但是这也带来一个小问题，就是每次sublayer输出的结果的为维度和原输入的维度应该一样，带来了一些限制。 Encoder在文章中encoder有6层，而其中的每一层包含两个sub-layer 第一个sub-layer是多头自注意力机制，用来计算文本内部的关联 第二个是全连接Position-wise Feed-forward Networks Decoder文章中decoder也是6层，其中的每一层包含三个sub-layer 第一个sub-layer是masked多头自注意力机制，原因很简单啊后面的结果还没生成呢！ 第二个sub-layer是多头注意力机制，将decoder和encoder结合，注意计算的时候$K,V$是由encoder提供的，decoder提供的是$Q$ 第三个是一个全链接网络Position-wise Feed-forward Networks The Final Linear and Softmax Layer 最后一层就比较简单了，简单来说就是首先把decoder的第6层输出经过一个神经网络对每个单词的可能性计算一个权值，再经过一个softmax是为了反向传播的时候有一个误差回传，使得整个网络能够训练。 这里还需要注意的是，每次输出的结果，都要像RNN一样作为输入传给decoder，依次输出结果。 transformer动画演示过程首先encoder的过程 接着就是decoder的过程 参考文献jalammar’s blog 苏剑林《《Attention is All You Need》浅读（简介+代码） 》]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>attention</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simplex-单纯形算法介绍]]></title>
    <url>%2FSimplex%2F</url>
    <content type="text"><![CDATA[单纯形算法（Simplex）有什么用？谈到单纯形算法，我们不得不提线性规划，所谓线性规划，就是在满足一定约束下优化目标函数。下面引用几个例子来进行简单介绍。 Food Energy Ca Price 燕麦 110 4 3 牛奶 160 8 9 猪肉 260 14 19 现在我们需要55个单位的Ca和2000个单位的Energy，问我们应该怎么购买最合适。这就是一类最经典的线性优化问题，我们可以很轻松的写出目标函数和约束条件： \begin{eqnarray} min && 3X_1+9X_2+19X_3\\ s.t.&& \\ && 110X_1+160X_2+260X_3>=2000\\ && 4X_1+8X_2+14X_3>=55\\ && X_i>=0，i=1,2,3\\ \end{eqnarray}​ 上述不等式表示的含义很简单，$min$表示最小化后面的目标函数，$s.t.$ 表示subject to的缩写，意思是受限于。 针对这类问题，我们曾经学过的方法是图解法，画出可行域（阴影部分）（a），之后使用目标函数(b)在可行域上移动，之后靠直觉确定最优解。 但是计算机可没有人类的直觉！计算机求解这些问题的时候，需要更加通用的方法来求解。于是在二战时期，为了协助政府协调物资人员，前苏联的坎托诺维奇强行提出了Simplex算法。其实该算法的思想也是来自于图解法，我们观察上面的求解过程，可以很明显的发现，最优解一定是在顶点上的！！！！于是这个人就在想，我们是不是随便从一个顶点开始，之后每次迁移到这个顶点的相邻顶点上，对这个凸包每个点遍历一次就能得到答案了？事实确实也确实是这样的，而且可以更简单，实际上我们只需要随便从一个顶点开始，之后暴力这个点相邻的点，然后选择一个下降的方向迁移点就可以，直到当前的点的值最小，那么这个点就是最终的解。 但是为什么可以这样做呢？按照我的理解，因为可行域是一个凸多边形(为什么是凸的？其实画一画，就知道了。不可能是凹的，可行域一定是凸的！！)，那么这个凸多边形的顶点结果是单调的，因为全局最优解只有一个。那么求解过程就好像下山一样，只要每次向下走就可以走到谷底，类似于梯度下降法在凸二次函数上每次沿着下降的方向走，一直迭代就能得到最优解。当然这些是在扯淡，实际上这玩意是被证明了的，而我没看。。。 单纯形算法适用的情况标准的线性规划格式（也叫标准型）： \begin{eqnarray} min && c^Tx\\ s.t. &&\\ &&A*x=0，i=1,2,3...,n\\ \end{eqnarray}其中$c​$表示的就是每一类$x​$的花费，$A​$表示的是约束矩阵，$x​$表示的是擦书的列向量，$x_i​$表示的是每一类的量(针对于整数线性规划，要求$x_i​$必须为整数，比如$x_i​$表示的是人的数量或者物品的份数) 但是有些时候我们可能碰到一些要最大化的最优化问题，比如我们固定钱数，怎么样买到的能量最多？这时候我们的优化目标变成了$max$，针对这类问题我们转换为标准形式的方式也很简单，$c*-1$ 就变为$min$ 了，同样的道理我们对$A$和$x$都可以这样干。 目标函数是$max$的时候，我们将$c$取反 $Ai*x&gt;=b$,我们将$A_i$和$b$取反 $x&lt;=0$,我们将$x$取反 松弛型我们上面介绍了标准型，现在介绍一下松弛型，其实也是一个很简单的东西，由于我们上面都是不等式，实在是太烦了，于是我们想要把不等式优化成等式，于是我们将标准型构造成下面的形式： \begin{eqnarray} min && c^Tx\\ s.t. &&\\ &&A_ix+x_{i+n}=b_i\\ && x_i>=0，i=1,2,3...,n+m\\ \end{eqnarray}其中$m​$表示约束的个数，由于之前的不等式都是$&gt;=​$的情况，我们可以减去一个非负的变量使得等号成立。这就是松弛形。 单纯形现在介绍单纯形，单纯形其实就是从松弛型过来的，它是为了单纯形算法求解简便一些而存在的，因为它可以导出单纯形表，一般写成如下形式： \begin{eqnarray} min && c^Tx\\ s.t. &&\\ &&x_{i+n}=b_i-A_ix\\ && x_i>=0，i=1,2,3...,n+m\\ \end{eqnarray}其中我们称左边的变量为基本变量，右边的变量称为非基本变量，我们很显然有一组基础解，就是令非基本变量为零，这时候基本变量的值都为其对应的$b_i​$。我们一般情况下可以认为基础解就是前面说的可行解区域的一个顶点（因为原本就是边界）。 而单纯形表的初始形式很简单，举个例子 \begin{eqnarray} min && -x_1&&-14x_2&&-6x_3\\ s.t.&&\\ &&+x_1&&+x_2&&+x_3&&+x_4&& && &&=4\\ &&+x_1&& &&&&&& +x_5&& &&=2\\ &&+x_3&& &&&&&&&&+x_6&&=3\\ \end{eqnarray}当前的例子的基本变量为${x_4,x_5,x_6}​$,非基本变量为${x_1,x_2,x_3}​$。 其单纯形表的形式为: 0 -1 -14 -6 0 0 0 4 1 1 1 1 0 0 2 1 0 0 0 1 0 3 0 0 1 0 0 1 人话解释，第一行表示的是目标函数的系数，但是其中第0个位置表示的是当前目标函数取当前基础解作为解之后求得的值的相反数。后面的每一行表示的都是约束条件$b_i=a_{i1}x_1+a_{i2}x_2+…+a_{i(n+m)}x_{n+m}$ 求解步骤我们在使用单纯形法进行求解的时候，首先找到第一个目标函数中系数为负的非基本变量$y$，将其增大（这个过程相当于我们在凸包上沿着边缘走到另一个顶点），但是我们怎么确定这个非基本变量$y$最大能增大多少呢？这个其实很简单，只需要令除当前变量的其他变量为0，剩下$b_i$和$y$，我们可以对每个包含$y$的约束条件进行计算约束。找到使其最紧(即在当前的约束条件中让$y$的最大取值最小)的那一个约束即可，再使用当前约束条件下的基本变量与其进行替换即可。由于我们每次可以使约束z向更小的方向迁移，这使得我们的算法不会陷入死循环。 注意，假如对于非基本变量$y$不存在限制最紧的约束条件，那么该组线性规划无解，因为可以无限增大。 再次注意我们的规则(Bland规则)： 找到第一个目标函数中系数为负的非基本变量 找到限制最紧的约束条件 使用当前约束条件下的基本变量(也叫替入变量)与非基本变量（也叫替出变量）进行替换 我们对上述单纯形表进行一次示范操作： 首先我们看到第一个非基本变量$x_1$的系数为负数。那么我们开始对$x_1$进行增大。 对于第一个约束条件有$x_1=4$ 对于第二个约束条件有$x_1=2$ 对于第三个约束条件有$x_1=3$ 由于第二个约束是最紧的，那么我们选择第二个约束中的$x_5$作为替出变量，此时有单纯形表的变化为 2 0 -14 -6 0 1 0 2 0 1 1 1 -1 0 2 1 0 0 0 1 0 3 0 0 1 0 0 1 由于我们在替出时将$x_1=2-x_5$带入，很明显可以将单纯形表进行转换。如果没有想清楚的话我们可以手动带入一下即可。 一直重复这个操作，直到所有的非基本变量的系数都大于零（顶点无法再迁移），那么程序就求出了最优解。 注意，本文其实未完待续，因为其实在实现算法中间存在很多细节，但本文的目的是让读者对该算法有个系统的了解，明白算法的原由，至于一些具体的细节，读者可以参考链接进行进一步的了解！ 单纯形Simplex模板给出一份Simplex的模板与其应用，所求解的题目链接：BZOJ 1061： 注意！！该模板求解的是： \begin{eqnarray} max && c^Tx\\ s.t.&&\\ &&A\cdot x>=b\\ &&x_i>=0,i=1,2,3,...,n \end{eqnarray}这类问题，稍稍转换一下就好了。之所以选择这个作为模板，是因为这份模板直接省去了替出变量，节省了大量空间，而且极其富有技巧性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;typedef double DB;typedef long long LL;const int maxn = 1005, maxm = 10005;const DB inf = 0x3f3f3f3f3f3f3f3f, eps = 1e-7;int n, m;DB b[maxm], c[maxn], cof[maxm][maxn], ans;//约束、目标函数的系数、约束矩阵inline void pivot(int id, int pos) &#123; b[id] /= cof[id][pos];//首先归一化 cof[id][pos] = 1 / cof[id][pos];//将变量直接改变为松弛变量，技巧的地方 for(int i = 1; i &lt;= n; i++) if(i != pos) cof[id][i] *= cof[id][pos];//归一化 for(int i = 1; i &lt;= m; i++) if(i != id &amp;&amp; fabs(cof[i][pos]) &gt; eps) &#123;//当前约束条件包含约束最紧的变量 b[i] -= cof[i][pos] * b[id];//搞死小圆(高斯消元)的方法更新变量的系数和b的值 for(int j = 1; j &lt;= n; j++) if(j != pos) cof[i][j] -= cof[i][pos] * cof[id][j]; cof[i][pos] = -cof[i][pos] * cof[id][pos];//将变量直接改变为松弛变量，技巧的地方 &#125; ans += c[pos] * b[id];//对c进行消元 for(int i = 1; i &lt;= n; i++) if(i != pos) c[i] -= c[pos] * cof[id][i]; c[pos] = -c[pos] * cof[id][pos];//将变量直接改变为松弛变量，技巧的地方&#125;inline DB simplex() &#123; while(1) &#123; int pos, id; for(pos = 1; pos &lt;= n; pos++) if(c[pos] &gt; eps) break;//找到第一个系数大于0的变量，进行增大 if(pos == n + 1) return ans;//找不到了结束，返回答案 DB tmp = inf; for(int i = 1; i &lt;= m; i++) if(cof[i][pos] &gt; eps &amp;&amp; b[i] / cof[i][pos] &lt; tmp) tmp = b[i] / cof[i][pos], id = i;//找到约束最紧的那个约束条件 if(tmp == inf) return inf; pivot(id, pos);//进行顶点的迁移（旋转） &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%lf", &amp;c[i]);//其实将min改为max问题，可以直接采用结论，求对偶问题即可。 for(int i = 1; i &lt;= m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); for(int j = x; j &lt;= y; j++) cof[i][j] = 1; scanf("%lf", &amp;b[i]); &#125; printf("%lld\n", LL(simplex() + 0.5)); return 0;&#125; 参考文献hrwhisper]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>Simplex</tag>
        <tag>最优化</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
</search>
